# 메모리 시스템

캐시 구조, 캐시 일관성, 메모리 대역폭을 설명합니다.

---

## 캐시 계층

```
┌─────────────────────────────────────────────────────────────────┐
│                    Cache Hierarchy                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                    ┌─────────┐                                 │
│                    │   CPU   │                                 │
│                    │  Core   │                                 │
│                    └────┬────┘                                 │
│                         │ ~1 cycle                              │
│                    ┌────▼────┐                                 │
│                    │L1 Cache │  32-64 KB                       │
│                    │ (I + D) │  (Instruction + Data 분리)      │
│                    └────┬────┘                                 │
│                         │ ~4 cycles                             │
│                    ┌────▼────┐                                 │
│                    │L2 Cache │  256 KB - 1 MB                  │
│                    │ (코어별)│                                 │
│                    └────┬────┘                                 │
│                         │ ~15 cycles                            │
│                    ┌────▼────┐                                 │
│                    │L3 Cache │  4 - 64 MB                      │
│                    │ (공유)  │  (모든 코어 공유)               │
│                    └────┬────┘                                 │
│                         │ ~100 cycles                           │
│                    ┌────▼────┐                                 │
│                    │  DRAM   │  8 - 128 GB                     │
│                    │(Main RAM│                                 │
│                    └─────────┘                                 │
│                                                                 │
│  Locality 원칙:                                                │
│  • Temporal: 최근 사용된 데이터는 다시 사용될 가능성 높음     │
│  • Spatial: 인접한 데이터도 사용될 가능성 높음                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 캐시 구조

```
┌─────────────────────────────────────────────────────────────────┐
│                    Cache Line 구조                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  메모리 주소 (32-bit 예시, 4KB 캐시, 64B 라인, 4-way):         │
│  ┌────────────────┬───────────┬──────────────┐                │
│  │     Tag        │   Index   │    Offset    │                │
│  │   (20 bits)    │ (4 bits)  │  (6 bits)    │                │
│  └────────────────┴───────────┴──────────────┘                │
│                                                                 │
│  Cache Set (4-way):                                            │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ Index │ Way 0        │ Way 1        │ Way 2  │ Way 3    │   │
│  │       │ Valid│Tag│Data│Valid│Tag│Data│ ...   │ ...      │   │
│  ├───────┼──────┼───┼────┼─────┼───┼────┼───────┼──────────┤   │
│  │   0   │  1   │T0 │ D0 │  1  │T1 │ D1 │       │          │   │
│  │   1   │  1   │T2 │ D2 │  0  │   │    │       │          │   │
│  │  ...  │      │   │    │     │   │    │       │          │   │
│  │  15   │  1   │Tn │ Dn │  1  │Tm │ Dm │       │          │   │
│  └───────┴──────┴───┴────┴─────┴───┴────┴───────┴──────────┘   │
│                                                                 │
│  연관도 (Associativity):                                       │
│  • Direct Mapped (1-way): 빠름, 충돌 많음                     │
│  • N-way Set Associative: 균형                                 │
│  • Fully Associative: 충돌 없음, 느림                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 캐시 정책

```
┌─────────────────────────────────────────────────────────────────┐
│                    Cache Policies                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Write Policy:                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ Write-Through:                                          │   │
│  │ • 캐시와 메모리 동시 쓰기                              │   │
│  │ • 일관성 보장, 느림                                    │   │
│  │                                                         │   │
│  │ Write-Back:                                             │   │
│  │ • 캐시만 쓰기, Dirty bit 설정                          │   │
│  │ • 퇴거 시에만 메모리 쓰기                              │   │
│  │ • 빠름, 복잡                                           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Replacement Policy:                                           │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ • LRU (Least Recently Used): 가장 오래 전 사용된 것    │   │
│  │ • FIFO: 먼저 들어온 것                                 │   │
│  │ • Random: 무작위                                       │   │
│  │ • Pseudo-LRU: 근사 LRU (구현 단순화)                   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Inclusion Policy:                                             │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ • Inclusive: L1 ⊆ L2 ⊆ L3 (Intel)                     │   │
│  │ • Exclusive: L1 ∩ L2 = ∅ (AMD)                        │   │
│  │ • Non-inclusive Non-exclusive: 자유                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 캐시 일관성

```
┌─────────────────────────────────────────────────────────────────┐
│                    Cache Coherence (MESI Protocol)              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  멀티코어 환경에서 각 코어의 캐시 동기화:                      │
│                                                                 │
│  상태:                                                          │
│  • M (Modified): 수정됨, 이 캐시만 유효                       │
│  • E (Exclusive): 독점, 깨끗함, 이 캐시만 보유                │
│  • S (Shared): 공유, 여러 캐시가 보유                         │
│  • I (Invalid): 무효                                           │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                         │   │
│  │        ┌───────────┐     Read from      ┌───────────┐  │   │
│  │        │     M     │────other core────►│     S     │  │   │
│  │        │ (Modified)│◄────Local Write────│ (Shared)  │  │   │
│  │        └─────┬─────┘                    └─────┬─────┘  │   │
│  │              │                                │         │   │
│  │    Evict     │                                │ Other   │   │
│  │              ▼                                ▼ Write   │   │
│  │        ┌───────────┐     Read Miss      ┌───────────┐  │   │
│  │        │     E     │◄───────────────────│     I     │  │   │
│  │        │(Exclusive)│────Local Write────►│ (Invalid) │  │   │
│  │        └───────────┘                    └───────────┘  │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Write가 발생하면 다른 코어의 캐시 라인을 Invalidate          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## False Sharing

```
┌─────────────────────────────────────────────────────────────────┐
│                    False Sharing                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  문제: 서로 다른 변수가 같은 캐시 라인에 있을 때               │
│                                                                 │
│  struct BadLayout {                                            │
│      int counter0;  // Core 0 사용                             │
│      int counter1;  // Core 1 사용                             │
│  };  // 같은 캐시 라인 (64 bytes 내)                           │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ Cache Line (64 bytes)                                    │  │
│  │ ┌──────────┬──────────┬──────────────────────────────┐  │  │
│  │ │ counter0 │ counter1 │          padding             │  │  │
│  │ └──────────┴──────────┴──────────────────────────────┘  │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  Core 0: counter0++                                            │
│    → 캐시 라인 Modified                                        │
│    → Core 1의 캐시 라인 Invalidate                             │
│                                                                 │
│  Core 1: counter1++                                            │
│    → 캐시 미스! 메모리에서 다시 로드                           │
│    → Core 0의 캐시 라인 Invalidate                             │
│                                                                 │
│  해결:                                                          │
│  struct GoodLayout {                                           │
│      alignas(64) int counter0;  // 별도 캐시 라인             │
│      alignas(64) int counter1;  // 별도 캐시 라인             │
│  };                                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 메모리 대역폭

```
┌─────────────────────────────────────────────────────────────────┐
│                    Memory Bandwidth                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  대역폭 계산:                                                   │
│  Bandwidth = 클럭 × 버스 폭 × 채널 수 × 전송율                │
│                                                                 │
│  예: DDR5-5600 Dual Channel                                    │
│  = 5600 MHz × 8 bytes × 2 channels × 2 (DDR)                  │
│  = 89.6 GB/s (이론적 최대)                                     │
│                                                                 │
│  비교:                                                          │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                         │   │
│  │  DDR4-3200    │████████████████│           51.2 GB/s   │   │
│  │  DDR5-5600    │████████████████████████│   89.6 GB/s   │   │
│  │  GDDR6       │████████████████████████████│ 384 GB/s   │   │
│  │  GDDR6X      │██████████████████████████████│ 672 GB/s │   │
│  │  HBM2e      │████████████████████████████████│ 1.6 TB/s│   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  GPU가 CPU보다 훨씬 높은 메모리 대역폭 필요                   │
│  (병렬 처리로 인한 대량의 데이터 처리)                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 메모리 접근 패턴

| 패턴 | 설명 | 성능 |
|------|------|------|
| Sequential | 연속 접근 | 최고 (Prefetch 효과적) |
| Strided | 일정 간격 | 보통 |
| Random | 무작위 | 최악 (캐시 미스 많음) |

```cpp
// 좋은 패턴: Sequential
for (int i = 0; i < N; i++) {
    sum += array[i];  // 캐시 친화적
}

// 나쁜 패턴: Column-major in Row-major array
for (int j = 0; j < M; j++) {
    for (int i = 0; i < N; i++) {
        sum += matrix[i][j];  // 캐시 비효율
    }
}
```

---

## 다음 단계

[GPU 아키텍처](04-gpu-architecture.md)에서 그래픽 프로세서를 알아봅니다.

