# CPU 설계

파이프라인, 분기 예측, 비순차 실행을 설명합니다.

---

## 파이프라인

```
┌─────────────────────────────────────────────────────────────────┐
│                    5-Stage Pipeline                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  단계:  IF    ID    EX    MEM   WB                             │
│        Fetch Decode Execute Memory Write                        │
│                             Access  Back                        │
│                                                                 │
│  비파이프라인 (Sequential):                                    │
│  ┌────────────────────────────────────────────────────────┐    │
│  │ Inst 1: │IF│ID│EX│MEM│WB│                              │    │
│  │ Inst 2:                  │IF│ID│EX│MEM│WB│              │    │
│  │ Inst 3:                                  │IF│ID│EX│MEM│WB│  │
│  └────────────────────────────────────────────────────────┘    │
│  5 cycles × 3 = 15 cycles                                      │
│                                                                 │
│  파이프라인 (Pipelined):                                       │
│  ┌────────────────────────────────────────────────────────┐    │
│  │ Inst 1: │IF│ID│EX│MEM│WB│                              │    │
│  │ Inst 2:    │IF│ID│EX │MEM│WB│                          │    │
│  │ Inst 3:       │IF│ID │EX │MEM│WB│                      │    │
│  └────────────────────────────────────────────────────────┘    │
│  5 + 2 = 7 cycles (이상적)                                     │
│                                                                 │
│  처리량: 파이프라인 채워지면 1 cycle당 1 instruction          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 파이프라인 해저드

```
┌─────────────────────────────────────────────────────────────────┐
│                    Pipeline Hazards                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Structural Hazard (구조적 해저드)                          │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 문제: 같은 하드웨어 자원에 동시 접근                     │   │
│  │ 예: 메모리를 IF와 MEM이 동시에 접근                     │   │
│  │ 해결: 자원 복제 (Instruction Cache / Data Cache 분리)   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  2. Data Hazard (데이터 해저드)                                │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 문제: 이전 명령의 결과를 다음 명령이 필요                │   │
│  │                                                         │   │
│  │   ADD R1, R2, R3    ; R1 = R2 + R3                     │   │
│  │   SUB R4, R1, R5    ; R4 = R1 - R5  ← R1 필요!        │   │
│  │                                                         │   │
│  │ 해결:                                                   │   │
│  │ • Stall: 결과 나올 때까지 대기 (느림)                  │   │
│  │ • Forwarding: EX 결과를 바로 다음 EX로 전달            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  3. Control Hazard (제어 해저드)                               │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 문제: 분기 명령의 결과를 모르면 다음 명령 불확실        │   │
│  │                                                         │   │
│  │   BEQ R1, R2, Label  ; R1 == R2면 Label로 점프        │   │
│  │   ADD ...            ; 실행할지 모름                   │   │
│  │   SUB ...            ; 실행할지 모름                   │   │
│  │                                                         │   │
│  │ 해결:                                                   │   │
│  │ • Stall: 분기 결정까지 대기 (느림)                     │   │
│  │ • Branch Prediction: 결과 예측 후 추측 실행            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 분기 예측

```
┌─────────────────────────────────────────────────────────────────┐
│                    Branch Prediction                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Static Prediction (정적 예측)                              │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ • Always Taken: 항상 분기한다고 예측                    │   │
│  │ • Always Not Taken: 항상 분기 안 한다고 예측            │   │
│  │ • Backward Taken: 뒤로 가면 분기 (루프 최적화)          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  2. Dynamic Prediction (동적 예측)                             │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                         │   │
│  │  2-bit Saturating Counter:                             │   │
│  │                                                         │   │
│  │  ┌─────────────┐     Taken     ┌─────────────┐        │   │
│  │  │  Strongly   │ ◄──────────── │   Weakly    │        │   │
│  │  │  Not Taken  │               │  Not Taken  │        │   │
│  │  │    (00)     │ ──────────►   │    (01)     │        │   │
│  │  └─────────────┘   Not Taken   └──────┬──────┘        │   │
│  │        ▲                              │               │   │
│  │        │                        Taken │               │   │
│  │   Not Taken                           ▼               │   │
│  │        │                       ┌──────────────┐       │   │
│  │  ┌─────┴───────┐               │    Weakly    │       │   │
│  │  │  Strongly   │ ◄──────────── │    Taken     │       │   │
│  │  │   Taken     │    Not Taken  │    (10)      │       │   │
│  │  │   (11)      │ ──────────►   └──────────────┘       │   │
│  │  └─────────────┘     Taken                            │   │
│  │                                                         │   │
│  │  현대 CPU: 95%+ 예측 정확도                            │   │
│  │  예측 실패 시: 파이프라인 Flush (10-20 cycles 손실)    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 비순차 실행

```
┌─────────────────────────────────────────────────────────────────┐
│                    Out-of-Order Execution                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  프로그램 순서:                                                │
│  1. LOAD R1, [MEM]    ; 메모리 로드 (느림, ~100 cycles)       │
│  2. ADD R2, R1, R3    ; R1 필요 (의존성)                      │
│  3. MUL R4, R5, R6    ; R1과 무관                             │
│  4. SUB R7, R8, R9    ; R1과 무관                             │
│                                                                 │
│  In-Order:                                                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ LOAD ████████████████████████████████████               │   │
│  │ ADD                                      ██             │   │
│  │ MUL                                        ██           │   │
│  │ SUB                                          ██         │   │
│  │ (LOAD 대기 중 MUL, SUB도 대기)                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Out-of-Order:                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ LOAD ████████████████████████████████████               │   │
│  │ MUL  ██  (먼저 실행!)                                   │   │
│  │ SUB    ██  (먼저 실행!)                                 │   │
│  │ ADD                                      ██             │   │
│  │ (의존성 없는 명령어는 병렬 실행)                        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  핵심 컴포넌트:                                                │
│  • Reservation Stations: 피연산자 대기                        │
│  • Reorder Buffer (ROB): 프로그램 순서 복원                   │
│  • Register Renaming: WAW/WAR 해저드 제거                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Superscalar

```
┌─────────────────────────────────────────────────────────────────┐
│                    Superscalar Architecture                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  단일 사이클에 여러 명령어 동시 실행:                          │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              Instruction Fetch (여러 개)               │   │
│  │                        │                                │   │
│  │              ┌─────────┴─────────┐                     │   │
│  │              ▼                   ▼                     │   │
│  │         ┌────────┐          ┌────────┐                │   │
│  │         │Decode 0│          │Decode 1│                │   │
│  │         └────┬───┘          └────┬───┘                │   │
│  │              │                   │                     │   │
│  │    ┌─────────┴───────┬───────────┴─────────┐          │   │
│  │    ▼                 ▼                     ▼          │   │
│  │ ┌──────┐         ┌──────┐              ┌──────┐       │   │
│  │ │ ALU  │         │ ALU  │              │ Load/│       │   │
│  │ │  0   │         │  1   │              │Store │       │   │
│  │ └──────┘         └──────┘              └──────┘       │   │
│  │                                                        │   │
│  │  IPC (Instructions Per Cycle): 2-6                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  현대 CPU (예: Zen 4, Golden Cove):                           │
│  • 6-wide decode                                               │
│  • 10+ execution units                                         │
│  • 300+ instructions in-flight                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## SIMD

```
┌─────────────────────────────────────────────────────────────────┐
│                    SIMD (Single Instruction Multiple Data)      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Scalar:                                                       │
│  ┌─────┐   ┌─────┐   ┌─────┐                                  │
│  │ A0  │ + │ B0  │ = │ C0  │  1번 연산                        │
│  └─────┘   └─────┘   └─────┘                                  │
│                                                                 │
│  SIMD (예: 128-bit SSE):                                       │
│  ┌─────┬─────┬─────┬─────┐   ┌─────┬─────┬─────┬─────┐       │
│  │ A0  │ A1  │ A2  │ A3  │ + │ B0  │ B1  │ B2  │ B3  │       │
│  └─────┴─────┴─────┴─────┘   └─────┴─────┴─────┴─────┘       │
│              │                                                  │
│              ▼                                                  │
│  ┌─────┬─────┬─────┬─────┐                                    │
│  │ C0  │ C1  │ C2  │ C3  │   4번 연산 동시에!                 │
│  └─────┴─────┴─────┴─────┘                                    │
│                                                                 │
│  발전:                                                          │
│  • SSE: 128-bit (4 × float)                                   │
│  • AVX: 256-bit (8 × float)                                   │
│  • AVX-512: 512-bit (16 × float)                              │
│                                                                 │
│  게임/그래픽에서 벡터/행렬 연산 가속                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 다음 단계

[메모리 시스템](03-memory-system.md)에서 캐시 구조를 알아봅니다.

