# 모바일 최적화

TBDR 아키텍처에 최적화된 렌더링 기법과 셰이더 최적화를 설명합니다.

---

## TBDR 최적화 원칙

### 핵심 원칙

```
┌─────────────────────────────────────────────────────────────────┐
│                    TBDR 최적화 핵심                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 대역폭 최소화                                               │
│     • 타일 메모리 내에서 최대한 처리                           │
│     • 시스템 메모리 접근 최소화                                │
│                                                                 │
│  2. HSR 활용 극대화                                             │
│     • 불투명 오브젝트 먼저 렌더링                              │
│     • Alpha Test/Discard 최소화                                │
│                                                                 │
│  3. Overdraw 방지                                               │
│     • Front-to-Back 정렬                                       │
│     • 적절한 컬링                                              │
│                                                                 │
│  4. 지오메트리 최적화                                           │
│     • 타일당 삼각형 수 제한                                    │
│     • 작은 삼각형 피하기                                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## DO: 권장 사항

### 1. Opaque 먼저 렌더링

```
┌─────────────────────────────────────────────────────────────────┐
│                    렌더링 순서                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  올바른 순서:                                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  1. Opaque Objects (Front-to-Back)                      │   │
│  │     → HSR이 가려진 픽셀 제거                            │   │
│  │                                                         │   │
│  │  2. Masked Objects (Alpha Test)                         │   │
│  │     → 필요한 경우에만 사용                              │   │
│  │                                                         │   │
│  │  3. Translucent Objects (Back-to-Front)                 │   │
│  │     → 정렬 후 블렌딩                                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  잘못된 순서:                                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Masked → Opaque → Translucent                          │   │
│  │  → HSR 효과 감소, Overdraw 증가                        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2. 텍스처 압축 사용

```
┌─────────────────────────────────────────────────────────────────┐
│                    권장 텍스처 포맷                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  포맷          │ bpp  │ 용도                                   │
│  ──────────────┼──────┼────────────────────────────────────────│
│  ASTC 4x4      │ 8    │ 고품질, 범용                           │
│  ASTC 6x6      │ 3.56 │ 중간 품질                              │
│  ASTC 8x8      │ 2    │ 저품질, 배경                           │
│  ETC2          │ 4~8  │ OpenGL ES 호환                         │
│                │                                                │
│  ASTC 장점:                                                     │
│  • 가변 블록 크기 (4x4 ~ 12x12)                                │
│  • RGB + Alpha 단일 포맷                                       │
│  • 품질/크기 트레이드오프 유연                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3. LOD 시스템 활용

```
┌─────────────────────────────────────────────────────────────────┐
│                    LOD 설정 권장                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  거리        │ LOD │ 삼각형 비율                               │
│  ────────────┼─────┼──────────────────────────────────────────│
│  0-10m       │  0  │ 100%                                      │
│  10-25m      │  1  │ 50%                                       │
│  25-50m      │  2  │ 25%                                       │
│  50m+        │  3  │ 10%                                       │
│                                                                 │
│  Auto LOD 설정:                                                 │
│  r.StaticMeshLODDistanceScale=1.0                              │
│  r.SkeletalMeshLODBias=0                                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4. 배치 처리

```cpp
// Draw Call 최소화
// 나쁜 예: 개별 드로우
for (auto& Object : Objects)
{
    DrawObject(Object);  // 100번 Draw Call
}

// 좋은 예: 인스턴싱
DrawInstancedObjects(Objects);  // 1번 Draw Call

// 머티리얼 통합
// 여러 텍스처 → 아틀라스로 통합
// 유사한 머티리얼 → 파라미터로 구분
```

---

## DON'T: 피해야 할 것

### 1. Alpha Test/Discard 남용

```
┌─────────────────────────────────────────────────────────────────┐
│                    Alpha Test 영향                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  문제점:                                                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  // 셰이더에서 discard 사용                              │   │
│  │  if (alpha < 0.5)                                        │   │
│  │      discard;  ← HSR 무효화!                            │   │
│  │                                                         │   │
│  │  결과:                                                   │   │
│  │  • 모든 픽셀이 셰이딩됨 (가려진 것도)                   │   │
│  │  • 렌더링 순서 보장 필요                                │   │
│  │  • TBDR 장점 상실                                       │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  대안:                                                          │
│  • Alpha Blend 사용 (가능한 경우)                              │
│  • Alpha to Coverage                                           │
│  • 불투명 지오메트리로 대체                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2. Z-Prepass 사용

```
┌─────────────────────────────────────────────────────────────────┐
│                    Z-Prepass가 불필요한 이유                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  데스크톱 (IMR):                                                │
│  • Z-Prepass로 Overdraw 방지 효과적                            │
│  • Depth만 먼저 기록 → 셰이딩 시 Early-Z 활용                  │
│                                                                 │
│  모바일 (TBDR):                                                 │
│  • HSR이 이미 Overdraw 방지                                    │
│  • Z-Prepass는 추가 Binning 비용만 발생                        │
│  • 오히려 성능 저하!                                           │
│                                                                 │
│  결론: 모바일에서는 Z-Prepass 비활성화                          │
│  r.EarlyZPass=0                                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3. Frame Buffer 읽기

```
┌─────────────────────────────────────────────────────────────────┐
│                    Frame Buffer 읽기 비용                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  문제 상황:                                                     │
│  • 이전 프레임 Scene Color 읽기                                │
│  • Depth 텍스처 샘플링                                         │
│  • 효과 간 의존성 (A → B → C)                                  │
│                                                                 │
│  결과:                                                          │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  타일 → System Memory → 타일                            │   │
│  │           ↑                                             │   │
│  │     전체 Resolve 필요!                                  │   │
│  │     대역폭 대량 사용                                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  해결:                                                          │
│  • Subpass 활용 (타일 내 데이터 유지)                          │
│  • 효과 통합 (여러 패스 → 단일 패스)                          │
│  • 저해상도 효과 분리                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 셰이더 최적화

### 정밀도 (Precision)

```hlsl
// 좋은 예: 적절한 정밀도 사용
half3 Color = half3(1.0h, 0.5h, 0.0h);     // FP16
mediump float2 UV = Input.UV;               // FP16
lowp float Alpha = 0.5;                     // 낮은 정밀도

// 나쁜 예: 불필요한 고정밀도
float3 Color = float3(1.0, 0.5, 0.0);      // FP32 (불필요)
highp float2 UV = Input.UV;                 // FP32 (불필요)
```

```
┌─────────────────────────────────────────────────────────────────┐
│                    정밀도 가이드                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  highp (float, FP32):                                          │
│  • World Position                                              │
│  • 정밀한 수학 연산                                            │
│  • 누적 연산                                                   │
│                                                                 │
│  mediump (half, FP16):                                         │
│  • Color                                                       │
│  • UV                                                          │
│  • Normal                                                      │
│  • 대부분의 라이팅 계산                                        │
│                                                                 │
│  lowp (fixed, 8-bit):                                          │
│  • Alpha                                                       │
│  • Mask 값                                                     │
│  • 0~1 범위 값                                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 텍스처 샘플링 최적화

```hlsl
// 나쁜 예: Dependent Texture Read
float2 UV = texture(DistortionMap, BaseUV).rg;  // 첫 번째 읽기
float4 Color = texture(ColorMap, UV);            // 의존적 읽기 (스톨)

// 좋은 예: 독립적 읽기
float4 Color = texture(ColorMap, BaseUV);
float4 Normal = texture(NormalMap, BaseUV);
// 두 샘플링이 병렬 실행 가능
```

### 분기 최소화

```hlsl
// 나쁜 예: 동적 분기
if (LightType == POINT_LIGHT)
    Color = CalculatePointLight(...);
else if (LightType == SPOT_LIGHT)
    Color = CalculateSpotLight(...);

// 좋은 예: 분기 회피
// 1. Shader Permutation 사용
// 2. 수학적 트릭으로 분기 제거
float IsPoint = step(0.5, LightType);
Color = lerp(SpotLightResult, PointLightResult, IsPoint);
```

---

## 메모리 최적화

### 텍스처 크기 가이드

```
┌─────────────────────────────────────────────────────────────────┐
│                    텍스처 크기 권장                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  용도              │ 최대 크기  │ 압축 포맷                    │
│  ──────────────────┼────────────┼────────────────────────────│
│  캐릭터 Diffuse    │ 1024x1024 │ ASTC 4x4                     │
│  캐릭터 Normal     │ 512x512   │ ASTC 4x4                     │
│  환경 Diffuse      │ 512x512   │ ASTC 6x6                     │
│  환경 Normal       │ 256x256   │ ASTC 4x4                     │
│  UI                │ 다양      │ ASTC 4x4 / 무압축            │
│  이펙트            │ 256x256   │ ASTC 6x6                     │
│                                                                 │
│  밉맵:                                                          │
│  • 3D 오브젝트: 항상 사용                                      │
│  • UI: 사용 안 함                                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 메모리 버짓

```
┌─────────────────────────────────────────────────────────────────┐
│                    메모리 버짓 예시                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  디바이스 RAM: 4GB 기준                                         │
│                                                                 │
│  항목              │ 할당량    │ 비고                          │
│  ──────────────────┼───────────┼────────────────────────────│
│  텍스처            │ 512MB     │ 스트리밍 풀                   │
│  메시              │ 256MB     │ LOD 포함                      │
│  오디오            │ 128MB     │ 스트리밍                      │
│  렌더 타겟         │ 128MB     │ 해상도 의존                   │
│  시스템/엔진       │ 256MB     │ 고정                          │
│  여유              │ 256MB     │ 피크 대응                     │
│  ──────────────────┼───────────┼────────────────────────────│
│  합계              │ ~1.5GB    │ OS 및 기타 앱 여유분 확보   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 프로파일링 도구

### UE 내장 도구

```cpp
// 콘솔 명령
stat GPU               // GPU 시간
stat SceneRendering    // 렌더링 통계
stat RHI               // RHI 레벨 통계
profilegpu             // GPU 프로파일 캡처

// 모바일 특화
stat Android           // Android 통계
stat IOS               // iOS 통계
```

### 외부 도구

| 도구 | GPU | 용도 |
|------|-----|------|
| **Snapdragon Profiler** | Adreno | Qualcomm 디바이스 |
| **Mali Graphics Debugger** | Mali | ARM 디바이스 |
| **PVRTune** | PowerVR | Imagination 디바이스 |
| **Xcode GPU Profiler** | Apple | iOS 디바이스 |
| **RenderDoc** | 범용 | 프레임 캡처 |

---

## 최적화 체크리스트

```
┌─────────────────────────────────────────────────────────────────┐
│                    모바일 최적화 체크리스트                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  렌더링:                                                        │
│  □ Opaque → Masked → Translucent 순서                         │
│  □ Alpha Test 최소화                                           │
│  □ Z-Prepass 비활성화                                          │
│  □ LOD 시스템 활용                                             │
│                                                                 │
│  셰이더:                                                        │
│  □ half/mediump 사용                                           │
│  □ 텍스처 샘플 16개 이하                                       │
│  □ 분기 최소화                                                 │
│  □ Dependent read 피하기                                       │
│                                                                 │
│  텍스처:                                                        │
│  □ ASTC 압축 사용                                              │
│  □ POT 크기                                                    │
│  □ 밉맵 활성화                                                 │
│  □ 채널 패킹                                                   │
│                                                                 │
│  메모리:                                                        │
│  □ 텍스처 스트리밍                                             │
│  □ 메시 LOD                                                    │
│  □ 렌더 타겟 크기 최적화                                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 참고 자료

- [ARM Mali Best Practices](https://developer.arm.com/documentation/102643/latest)
- [Qualcomm Adreno Optimization](https://developer.qualcomm.com/software/adreno-gpu-sdk)
- [Apple Metal Best Practices](https://developer.apple.com/documentation/metal/gpu_programming_techniques)
- [원본 문서 (timlly)](https://www.cnblogs.com/timlly/p/15574911.html)
