# RDG 개요

> 원문: [剖析虚幻渲染体系（11）- RDG](https://www.cnblogs.com/timlly/p/15217090.html)

RDG(Rendering Dependency Graph)의 개념, 배경, 그리고 현대 그래픽 API와의 관계를 설명합니다.

---

## 11.1.1 RDG의 정의

**RDG (Rendering Dependency Graph, 렌더 의존성 그래프)**는 UE4.22에서 도입된 새로운 렌더링 서브시스템입니다. 유향 비순환 그래프(Directed Acyclic Graph, DAG) 기반의 스케줄링 프레임워크로, **"전체 프레임 최적화를 통한 렌더링 파이프라인 성능 향상"**을 목표로 합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    RDG 핵심 정의                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  RDG = Rendering Dependency Graph                               │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                         │   │
│  │  • 유향 비순환 그래프(DAG) 기반 스케줄링 시스템          │   │
│  │  • UE4.22+ 렌더링 파이프라인의 핵심 구성요소            │   │
│  │  • 현대 그래픽 API(DX12, Vulkan, Metal 2) 최적화        │   │
│  │  • 프레임 단위 전역 최적화 수행                         │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  핵심 최적화 기능:                                              │
│  1. 비동기 컴퓨트 Pass의 자동 스케줄링 및 격리                 │
│  2. 프레임 내 비중첩 시간대에서의 리소스 앨리어싱              │
│  3. 배리어 및 레이아웃 전환의 선제적 처리로 파이프라인 지연 방지│
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

이 시스템은 현대 그래픽 API(DirectX 12, Vulkan, Metal 2)의 능력을 활용하여 세 가지 핵심 최적화를 달성합니다:

- **비동기 컴퓨트 자동 스케줄링**: Compute Pass를 Graphics Pass와 분리하여 병렬 실행
- **리소스 앨리어싱**: 생명주기가 겹치지 않는 리소스가 동일 메모리 공유
- **배리어 최적화**: 상태 전환을 미리 배치하여 파이프라인 지연(stall) 방지

---

## 11.1.2 전통 vs 현대 그래픽 API

### 전통 API의 한계 (DirectX 11, OpenGL)

전통 그래픽 API에서는 **드라이버가 복잡한 휴리스틱**을 사용하여 GPU 스케줄링, 메모리 관리, 캐시 플러시, 레이아웃 전환 등을 결정해야 했습니다. 이러한 즉시 실행(Immediate Mode) 방식은 복잡한 상태 추적을 요구하며, 결과적으로 **"성능에 부정적인 영향을 미치고 병렬화를 방해"**합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                전통 API의 문제점                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Application        Driver              GPU                     │
│       │                │                  │                     │
│       │  Draw Call     │                  │                     │
│       │───────────────▶│                  │                     │
│       │                │  Heuristic       │                     │
│       │                │  Decision        │                     │
│       │                │  ┌──────────┐   │                     │
│       │                │  │ 언제 실행?│   │                     │
│       │                │  │ 메모리?  │   │                     │
│       │                │  │ 캐시?    │   │                     │
│       │                │  │ 배리어?  │   │                     │
│       │                │  └──────────┘   │                     │
│       │                │─────────────────▶│                     │
│       │                │                  │                     │
│                                                                 │
│  문제점:                                                        │
│  • 드라이버가 전체 프레임 컨텍스트 부재                         │
│  • 휴리스틱 기반 결정 → 최적이 아닌 경우 발생                  │
│  • 복잡한 내부 상태 추적 필요                                   │
│  • 병렬화 기회 상실                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 현대 API의 장점 (DirectX 12, Vulkan, Metal 2)

현대 그래픽 API는 **저수준 GPU 관리 책임을 애플리케이션 레이어로 이전**합니다. 이를 통해 개발자는 전체 렌더링 파이프라인의 컨텍스트 정보를 활용하여 스케줄링 결정을 내릴 수 있으며, 결과적으로 **"성능 향상과 렌더링 스택 단순화"**를 달성합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                현대 API의 장점                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Application (RDG)                      GPU                     │
│       │                                   │                     │
│       │  전체 프레임 정보 보유             │                     │
│       │  ┌────────────────────────┐       │                     │
│       │  │ Pass A → Pass B → ...  │       │                     │
│       │  │ 리소스 생명주기 파악   │       │                     │
│       │  │ 최적 배리어 위치 결정  │       │                     │
│       │  │ 병렬 실행 기회 식별    │       │                     │
│       │  └────────────────────────┘       │                     │
│       │                                   │                     │
│       │  최적화된 명령 배치               │                     │
│       │──────────────────────────────────▶│                     │
│       │                                   │                     │
│                                                                 │
│  장점:                                                          │
│  • 애플리케이션이 전체 프레임 컨텍스트 보유                     │
│  • 최적의 스케줄링 결정 가능                                   │
│  • 명시적 메모리/배리어 제어                                   │
│  • 병렬화 기회 극대화                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### API 비교 요약

| 구분 | 전통 API (DX11, OpenGL) | 현대 API (DX12, Vulkan, Metal 2) |
|------|-------------------------|-----------------------------------|
| **책임 분배** | 드라이버가 대부분 담당 | 애플리케이션이 저수준 관리 |
| **상태 관리** | 드라이버 내부 추적 | 애플리케이션 명시적 관리 |
| **배리어** | 드라이버가 휴리스틱으로 삽입 | 애플리케이션이 명시적 삽입 |
| **메모리** | 드라이버가 관리 | 애플리케이션이 힙/풀 관리 |
| **최적화** | 국소적 최적화만 가능 | 전체 프레임 최적화 가능 |
| **병렬화** | 제한적 | GPU 다중 큐 활용 가능 |

---

## 11.1.3 Frame Graph의 기원

RDG의 개념적 기반은 업계에서 먼저 등장했습니다. **EA의 Frostbite 엔진**이 2017년 GDC에서 **Frame Graph** 기술을 발표했으며, 이 방안의 설계 목표는 **"렌더링 기능, 렌더링 로직, 저수준 리소스를 분리하여 멀티스레드 및 병렬 렌더링을 지원"**하는 것이었습니다.

![RDG 의존성 그래프](../images/ch11/1617944-20201026110615588-1410809244.png)

```
┌─────────────────────────────────────────────────────────────────┐
│                Frame Graph 설계 목표                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Frostbite Engine의 Frame Graph (GDC 2017)                      │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                         │   │
│  │  목표: "렌더링 기능, 렌더링 로직, 저수준 리소스의 분리" │   │
│  │                                                         │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │   │
│  │  │ 렌더링 기능   │  │ 렌더링 로직   │  │ 저수준 리소스 │  │   │
│  │  │ (Features)   │  │  (Logic)     │  │ (Resources)  │  │   │
│  │  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘  │   │
│  │         │                 │                 │          │   │
│  │         └─────────────────┼─────────────────┘          │   │
│  │                           ▼                            │   │
│  │                   ┌──────────────┐                     │   │
│  │                   │ Frame Graph  │                     │   │
│  │                   │   (DAG)      │                     │   │
│  │                   └──────────────┘                     │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Frame Graph 구현 방식:                                         │
│  • Pass와 리소스를 고수준 추상화로 표현                        │
│  • Pass 간 순서와 의존성을 명시적으로 지정                     │
│  • 한 프레임의 모든 렌더링 정보를 DAG 형태로 통합              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

Frame Graph는 다음 방식으로 목표를 달성합니다:
- **Pass와 리소스를 고수준 추상화로 표현**
- **Pass 간 순서와 의존성을 명시적으로 지정**
- **한 프레임의 모든 렌더링 정보를 DAG 형태로 통합**

---

## 11.1.4 UE RDG와 Frame Graph

UE의 RDG 시스템은 본질적으로 **"Frame Graph 기반의 커스터마이징된 구현"**입니다. UE 4.26 버전 기준으로 RDG는 이미 씬 렌더링, 포스트 프로세싱, 레이 트레이싱 등 핵심 모듈에 광범위하게 적용되어 있습니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                UE RDG 적용 범위 (4.26+)                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                     UE4 렌더러                           │   │
│  ├─────────────────────────────────────────────────────────┤   │
│  │                                                         │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │   │
│  │  │ Scene       │  │ Post        │  │ Ray         │     │   │
│  │  │ Rendering   │  │ Processing  │  │ Tracing     │     │   │
│  │  │             │  │             │  │             │     │   │
│  │  │ • GBuffer   │  │ • Bloom     │  │ • RTGI      │     │   │
│  │  │ • Lighting  │  │ • DOF       │  │ • RTAO      │     │   │
│  │  │ • Shadows   │  │ • TAA       │  │ • RT Shadows│     │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘     │   │
│  │         │                │                │             │   │
│  │         └────────────────┼────────────────┘             │   │
│  │                          ▼                              │   │
│  │                   ┌─────────────┐                       │   │
│  │                   │    RDG      │                       │   │
│  │                   │ (FRDGBuilder)│                      │   │
│  │                   └─────────────┘                       │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 11.1.5 RDG 작동 원리

RDG는 GPU 명령을 즉시 실행하지 않습니다. 대신 Lambda 기반의 렌더링 Pass를 수집하고, 모든 Pass가 수집된 후 의존성을 분석하여 최적화된 순서로 실행합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    RDG 실행 4단계                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Pass 수집 (Setup Phase)                                     │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ • AddPass() 호출로 FRDGPass 인스턴스 생성            │    │
│     │ • 텍스처/버퍼 상태 처리 (SetupPass)                  │    │
│     │ • 리소스 의존성 및 참조 기록                          │    │
│     │ • Graphics 파이프라인에서 리소스 생명주기 시작점 표시 │    │
│     └─────────────────────────────────────────────────────┘    │
│                           ▼                                     │
│  2. Pass 컴파일 (Compile Phase)                                 │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ • 생산자/소비자 의존성 관계 구축                      │    │
│     │ • Pass 컬링 (Dead Code 제거)                         │    │
│     │ • 리소스 상태 병합 및 중복 전환 제거                  │    │
│     │ • 비동기 컴퓨트 처리 (Fork/Join 포인트 설정)          │    │
│     │ • 동일 RT의 래스터 Pass 병합                         │    │
│     └─────────────────────────────────────────────────────┘    │
│                           ▼                                     │
│  3. Pass 실행 (Execute Phase)                                   │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ • Prologue: 배리어 제출, RenderPass 시작             │    │
│     │ • Body: Lambda 인스턴스 실행                        │    │
│     │ • Epilogue: RenderPass 종료, 리소스 해제             │    │
│     └─────────────────────────────────────────────────────┘    │
│                           ▼                                     │
│  4. 정리 (Cleanup Phase)                                        │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ • 텍스처/버퍼 추출 처리                              │    │
│     │ • 할당된 모든 메모리 해제                            │    │
│     │ • 데이터 구조 리셋                                   │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 핵심 원칙

```
┌─────────────────────────────────────────────────────────────────┐
│                    RDG 핵심 원칙                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 【지연 실행 (Deferred Execution)】                           │
│     • Pass는 AddPass() 호출 시 즉시 실행되지 않음                │
│     • 모든 Pass 수집 후 Compile → Execute 순서로 진행            │
│     • 전체 프레임 컨텍스트 기반 최적화 가능                      │
│                                                                 │
│  2. 【자동 리소스 관리】                                         │
│     • CreateTexture/CreateBuffer는 디스크립터만 기록             │
│     • 실제 할당은 Compile 단계에서 필요할 때 수행                │
│     • 참조가 없으면 자동 해제 (풀로 반환)                        │
│                                                                 │
│  3. 【의존성 기반 스케줄링】                                      │
│     • Pass 간 실행 순서는 등록 순서가 아닌 의존성으로 결정       │
│     • 오직 데이터 의존성만 보존됨                                │
│     • 출력에 영향 없는 Pass는 자동 컬링                          │
│                                                                 │
│  4. 【Pass 범위 내 접근】                                        │
│     • 리소스 접근은 Pass Lambda 내에서만 가능                    │
│     • Pass 파라미터에 선언된 리소스만 사용 가능                  │
│     • Execute() 전에 RDG 리소스의 RHI 리소스 직접 접근 불가      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 11.1.6 RDG의 주요 최적화

### Pass 컬링 (Dead Code Elimination)

출력에 영향을 주지 않는 Pass를 자동으로 제거합니다. DFS(깊이 우선 탐색)를 사용하여 외부 출력이 있는 Pass부터 역으로 추적하여 필수 Pass를 마킹하고, 나머지는 컬링합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    Pass 컬링 메커니즘                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  컬링 전:                           컬링 후:                    │
│                                                                 │
│  ┌───────┐                          ┌───────┐                  │
│  │Pass A │──┐                       │Pass A │                  │
│  └───────┘  │                       └───┬───┘                  │
│             ▼                           │                       │
│  ┌───────┐ ┌───────┐                    │     Pass B: 컬링됨   │
│  │Pass B │ │Pass C │                    │     (출력 미사용)    │
│  └───┬───┘ └───┬───┘                    │                       │
│      │         │                        │                       │
│      ▼         │                        ▼                       │
│  ┌───────┐     │                ┌───────┐                      │
│  │Pass D │     │                │Pass C │                      │
│  │(미사용)│     │                └───┬───┘                      │
│  └───────┘     │                    │     Pass D: 컬링됨       │
│                ▼                    ▼                          │
│           ┌───────┐            ┌───────┐                       │
│           │Output │            │Output │                       │
│           └───────┘            └───────┘                       │
│                                                                 │
│  컬링 조건:                                                     │
│  • 추적되는 출력이 없고                                        │
│  • NeverCull로 마킹되지 않은 Pass                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### RenderPass 병합

동일한 렌더 타겟을 사용하는 연속된 래스터 Pass를 하나의 RHI RenderPass로 병합하여 `BeginRenderPass/EndRenderPass` 호출 오버헤드를 줄입니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    RenderPass 병합                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  병합 전:                                                       │
│  ┌────────────────────────────────────────────────────────┐    │
│  │ BeginRenderPass(RT: GBuffer)                            │    │
│  │   DrawBasePass()                                        │    │
│  │ EndRenderPass()                                         │    │
│  │                                                         │    │
│  │ BeginRenderPass(RT: GBuffer)  ← 동일 RT                │    │
│  │   DrawDecals()                                          │    │
│  │ EndRenderPass()                                         │    │
│  │                                                         │    │
│  │ BeginRenderPass(RT: GBuffer)  ← 동일 RT                │    │
│  │   DrawDebugPrimitives()                                 │    │
│  │ EndRenderPass()                                         │    │
│  └────────────────────────────────────────────────────────┘    │
│                                                                 │
│  병합 후:                                                       │
│  ┌────────────────────────────────────────────────────────┐    │
│  │ BeginRenderPass(RT: GBuffer)                            │    │
│  │   DrawBasePass()                                        │    │
│  │   DrawDecals()        ← 병합됨                         │    │
│  │   DrawDebugPrimitives()  ← 병합됨                      │    │
│  │ EndRenderPass()                                         │    │
│  └────────────────────────────────────────────────────────┘    │
│                                                                 │
│  효과:                                                          │
│  • LoadAction/StoreAction 호출 감소                            │
│  • 타일 기반 GPU에서 특히 효과적 (모바일)                      │
│  • 메모리 대역폭 절약                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 배리어 최적화

리소스 상태 병합을 통해 중복 전환을 제거하고, 연속된 배리어를 배치 처리합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    배리어 병합 최적화                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  최적화 전:                                                     │
│  ┌──────┐ Barrier ┌──────┐ Barrier ┌──────┐ Barrier ┌──────┐  │
│  │Pass A│────────▶│Pass B│────────▶│Pass C│────────▶│Pass D│  │
│  └──────┘         └──────┘         └──────┘         └──────┘  │
│           Tex1→SRV        Tex2→SRV        Tex3→SRV            │
│                                                                 │
│  최적화 후:                                                     │
│  ┌──────┐                                           ┌──────┐  │
│  │Pass A│  Batched Barrier (Tex1, Tex2, Tex3)      │Pass D│  │
│  └──────┘─────────────────────────────────────────▶└──────┘  │
│                                                                 │
│  최적화 원리:                                                   │
│  • 연속된 배리어를 하나의 배치로 병합                          │
│  • 불필요한 동기화 포인트 제거                                  │
│  • Read → Read 전환 생략 (배리어 불필요)                       │
│  • 호환 가능한 접근 모드 병합                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 메모리 앨리어싱

생명주기가 겹치지 않는 리소스는 동일한 메모리 풀을 공유합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    메모리 앨리어싱                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  시간 →   Pass1    Pass2    Pass3    Pass4    Pass5            │
│            │        │        │        │        │               │
│                                                                 │
│  앨리어싱 없음:                                                  │
│  Tex A:    ████████████████                                    │
│  Tex B:             ███████████████████████                    │
│  Tex C:                      █████████                         │
│  메모리: [====A====][====B====][====C====]                      │
│                                                                 │
│  앨리어싱 적용:                                                  │
│  Tex A:    ████████████████                                    │
│  Tex B:             ███████████████████████                    │
│  Tex C:                      █████████  ← A가 반환한 메모리     │
│  메모리: [========Shared Memory Pool========]                   │
│                                                                 │
│  • 첫 사용 시점에 풀에서 할당                                   │
│  • 마지막 사용 후 즉시 풀로 반환                                │
│  • 반환된 메모리를 후속 리소스가 재사용                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 11.1.7 RDG 최적화 요약

| 최적화 기능 | 설명 | 효과 |
|-------------|------|------|
| **Pass 컬링** | 출력에 영향 없는 Pass 자동 제거 | GPU 작업량 감소 |
| **RenderPass 병합** | 동일 RT의 래스터 Pass 통합 | API 호출 감소 |
| **배리어 최적화** | 중복 전환 제거, 배치 처리 | 파이프라인 지연 감소 |
| **메모리 앨리어싱** | 비중첩 리소스 메모리 공유 | 메모리 사용량 감소 |
| **비동기 컴퓨트** | Graphics/Compute 병렬 실행 | GPU 활용률 향상 |
| **자동 생명주기** | 첫 사용 시 할당, 미사용 시 해제 | 메모리 효율성 |

---

## 다음 단계

[RDG 기초 타입](02-rdg-fundamentals.md)에서 플래그, 리소스 타입, FRDGBuilder 클래스를 상세히 알아봅니다.
