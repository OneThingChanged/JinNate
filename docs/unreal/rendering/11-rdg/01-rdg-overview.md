# RDG 개요

UE4.22에서 도입된 RDG(Rendering Dependency Graph)의 개념과 현대 그래픽 API와의 관계를 설명합니다.

---

## RDG란?

**RDG (Rendering Dependency Graph)**는 유향 비순환 그래프(Directed Acyclic Graph, DAG) 기반의 스케줄링 시스템으로, 전체 프레임 렌더링 파이프라인의 최적화를 위해 설계되었습니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    RDG 개념도                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                    ┌─────────┐                                  │
│                    │ Pass A  │                                  │
│                    │(Shadow) │                                  │
│                    └────┬────┘                                  │
│                         │                                       │
│              ┌──────────┴──────────┐                           │
│              ▼                     ▼                           │
│        ┌─────────┐           ┌─────────┐                       │
│        │ Pass B  │           │ Pass C  │                       │
│        │(GBuffer)│           │(AO)     │                       │
│        └────┬────┘           └────┬────┘                       │
│              │                     │                           │
│              └──────────┬──────────┘                           │
│                         ▼                                       │
│                    ┌─────────┐                                  │
│                    │ Pass D  │                                  │
│                    │(Lighting)│                                 │
│                    └─────────┘                                  │
│                                                                 │
│   DAG 구조로 Pass 간 의존성을 표현하고 최적화 수행               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 도입 배경

### 기존 방식의 문제점

1. **수동 리소스 관리**: 개발자가 직접 리소스 생명주기를 관리
2. **비효율적 배리어**: 중복된 상태 전환이 발생
3. **메모리 낭비**: 리소스가 필요 이상으로 오래 유지됨
4. **최적화 한계**: 전체 프레임을 고려한 최적화 어려움

### RDG 솔루션

```
┌─────────────────────────────────────────────────────────────────┐
│                기존 방식 vs RDG 방식                             │
├────────────────────────────┬────────────────────────────────────┤
│        기존 방식            │           RDG 방식                 │
├────────────────────────────┼────────────────────────────────────┤
│ 수동 리소스 생성/해제       │ 자동 생명주기 관리                  │
│ 명시적 배리어 삽입          │ 자동 배리어 처리                    │
│ 즉시 실행                  │ 지연 실행 (Deferred)               │
│ Pass별 개별 최적화         │ 전체 프레임 최적화                  │
│ 메모리 단편화              │ 리소스 풀링/앨리어싱               │
└────────────────────────────┴────────────────────────────────────┘
```

---

## 현대 그래픽 API와의 관계

RDG는 DirectX 12, Vulkan, Metal 2 등 현대 그래픽 API의 기능을 최대한 활용합니다.

### 주요 활용 기능

| API 기능 | RDG 활용 |
|----------|----------|
| **Explicit Memory Management** | 리소스 풀링, 앨리어싱 |
| **Resource Barriers** | 자동 배리어 배치 및 최적화 |
| **Async Compute** | 자동 비동기 컴퓨트 스케줄링 |
| **Render Passes** | Pass 병합으로 호출 최소화 |
| **Command Lists** | 효율적 커맨드 배치 |

### Vulkan 예시: 배리어 처리

```cpp
// RDG 없이 (수동 배리어)
vkCmdPipelineBarrier(
    cmdBuffer,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
    ...
);

// RDG 사용 (자동 처리)
// Pass 간 리소스 의존성만 선언하면 RDG가 최적의 배리어 자동 삽입
GraphBuilder.AddPass(...);  // 의존성 기반 자동 배리어
```

---

## RDG 실행 흐름

```
┌─────────────────────────────────────────────────────────────────┐
│                    RDG 실행 4단계                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Pass 수집 (Setup Phase)                                     │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ • AddPass() 호출로 FRDGPass 인스턴스 생성            │    │
│     │ • 텍스처/버퍼 상태 처리 (SetupPass)                  │    │
│     │ • 리소스 의존성 및 참조 기록                          │    │
│     └─────────────────────────────────────────────────────┘    │
│                           ▼                                     │
│  2. Pass 컴파일 (Compile Phase)                                 │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ • 생산자/소비자 의존성 관계 구축                      │    │
│     │ • Pass 컬링 마크 결정                                │    │
│     │ • 리소스 전환 및 배리어 처리                          │    │
│     │ • 비동기 컴퓨트 Pass 의존성 처리                      │    │
│     │ • Fork/Join 노드 설정                               │    │
│     │ • 동일 RT의 래스터 Pass 병합                         │    │
│     └─────────────────────────────────────────────────────┘    │
│                           ▼                                     │
│  3. Pass 실행 (Execute Phase)                                   │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ • Prologue: 전위 배리어, 렌더 타겟 설정              │    │
│     │ • Body: Lambda 인스턴스 실행                        │    │
│     │ • Epilogue: 후위 배리어, 리소스 정리                 │    │
│     └─────────────────────────────────────────────────────┘    │
│                           ▼                                     │
│  4. 정리 (Cleanup Phase)                                        │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ • 할당된 모든 메모리 해제                            │    │
│     │ • 데이터 구조 리셋                                   │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 주요 최적화

### 1. Pass 컬링

출력에 영향을 주지 않는 Pass를 자동으로 제거합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    Pass 컬링 예시                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  컬링 전:                        컬링 후:                       │
│                                                                 │
│  ┌───────┐                       ┌───────┐                     │
│  │Pass A │───┐                   │Pass A │                     │
│  └───────┘   │                   └───┬───┘                     │
│              ▼                       │                          │
│  ┌───────┐ ┌───────┐                 │                          │
│  │Pass B │ │Pass C │                 │     Pass B 제거됨        │
│  └───┬───┘ └───┬───┘                 │     (출력 미사용)        │
│      │         │                     │                          │
│      ▼         │                     ▼                          │
│  ┌───────┐     │             ┌───────┐                         │
│  │Pass D │     │             │Pass C │                         │
│  │(미사용)│     │             └───┬───┘                         │
│  └───────┘     │                 │                              │
│                ▼                 ▼                              │
│           ┌───────┐         ┌───────┐                          │
│           │Output │         │Output │                          │
│           └───────┘         └───────┘                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2. Pass 병합

동일한 렌더 타겟을 사용하는 래스터 Pass를 하나의 Render Pass로 병합합니다.

```cpp
// 병합 전: 각각 Begin/EndRenderPass 호출
BeginRenderPass(RT);
  DrawPass1();
EndRenderPass();
BeginRenderPass(RT);  // 동일 RT
  DrawPass2();
EndRenderPass();

// 병합 후: 하나의 Render Pass
BeginRenderPass(RT);
  DrawPass1();
  DrawPass2();  // 병합됨
EndRenderPass();
```

### 3. 메모리 앨리어싱

생명주기가 겹치지 않는 리소스는 동일한 메모리를 공유합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    메모리 앨리어싱                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  시간 →                                                         │
│                                                                 │
│  앨리어싱 없음:                                                  │
│  ┌──────────────┐                                               │
│  │  Texture A   │                                               │
│  └──────────────┘                                               │
│           ┌──────────────┐                                      │
│           │  Texture B   │                                      │
│           └──────────────┘                                      │
│                    ┌──────────────┐                             │
│                    │  Texture C   │                             │
│                    └──────────────┘                             │
│  메모리: [====A====][====B====][====C====]                      │
│                                                                 │
│  앨리어싱 적용:                                                  │
│  ┌──────────────┐                                               │
│  │  Texture A   │                                               │
│  └──────────────┘                                               │
│           ┌──────────────┐                                      │
│           │  Texture B   │  ← A와 메모리 공유                   │
│           └──────────────┘                                      │
│                    ┌──────────────┐                             │
│                    │  Texture C   │  ← B와 메모리 공유          │
│                    └──────────────┘                             │
│  메모리: [====Shared Memory Pool====]                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 한계점

| 한계 | 설명 |
|------|------|
| **복잡성 증가** | 엔진 학습 비용 증가 |
| **디버깅 어려움** | 지연 실행으로 인한 문제 추적 난이도 |
| **생명주기 연장** | 일부 리소스가 불필요하게 오래 유지될 수 있음 |

---

## 다음 단계

[RDG 기초 타입](02-rdg-fundamentals.md)에서 플래그, 리소스 타입, 메모리 할당자를 알아봅니다.
