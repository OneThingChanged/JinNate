# RDG 메커니즘

RDG의 의존성 관리, 컴파일, 실행 메커니즘을 상세히 설명합니다.

---

## Pass 의존성 관리

### 생산자-소비자 관계

RDG는 리소스 사용 패턴을 분석하여 자동으로 의존성을 구축합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    생산자-소비자 관계                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Pass A (생산자)              Pass B (소비자)                   │
│  ┌─────────────────┐         ┌─────────────────┐               │
│  │ Output: Tex1    │────────▶│ Input: Tex1     │               │
│  │ (RenderTarget)  │         │ (ShaderResource)│               │
│  └─────────────────┘         └─────────────────┘               │
│                                                                 │
│  의존성 규칙:                                                   │
│  • Write → Read: 명시적 의존성                                  │
│  • Read → Read: 의존성 없음 (병렬 실행 가능)                    │
│  • Write → Write: 순서 의존성                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 의존성 그래프 구축

```cpp
// Pass A: 텍스처에 렌더링
GraphBuilder.AddPass(
    RDG_EVENT_NAME("PassA_Render"),
    Parameters_A,
    ERDGPassFlags::Raster,
    [](FRHICommandList& RHICmdList) { /* 렌더링 */ }
);

// Pass B: Pass A의 결과를 읽어서 처리
GraphBuilder.AddPass(
    RDG_EVENT_NAME("PassB_Process"),
    Parameters_B,  // Parameters_B->InputTexture = Parameters_A->OutputTexture
    ERDGPassFlags::Compute,
    [](FRHICommandList& RHICmdList) { /* 처리 */ }
);

// RDG가 자동으로 A → B 의존성 설정
```

---

## 컴파일 단계 상세

### Compile() 함수의 역할

```
┌─────────────────────────────────────────────────────────────────┐
│                    컴파일 단계 세부 과정                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. SetupPassDependencies()                                     │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ • 각 Pass의 리소스 사용 분석                         │    │
│     │ • 생산자/소비자 관계 테이블 구축                      │    │
│     │ • 리소스별 첫 번째/마지막 사용 Pass 기록             │    │
│     └─────────────────────────────────────────────────────┘    │
│                           ▼                                     │
│  2. SetupPassCulling()                                          │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ • 출력에 영향 없는 Pass 마킹                         │    │
│     │ • NeverCull 플래그 확인                              │    │
│     │ • 외부 추출 리소스 생산 Pass 유지                    │    │
│     └─────────────────────────────────────────────────────┘    │
│                           ▼                                     │
│  3. SetupResourceTransitions()                                  │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ • 상태 전환이 필요한 리소스 식별                     │    │
│     │ • 배리어 배치 위치 결정                              │    │
│     │ • 중복 전환 제거                                     │    │
│     └─────────────────────────────────────────────────────┘    │
│                           ▼                                     │
│  4. SetupAsyncComputePasses()                                   │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ • 비동기 컴퓨트 Pass 분리                           │    │
│     │ • Fork/Join 포인트 설정                             │    │
│     │ • 교차 큐 의존성 처리                                │    │
│     └─────────────────────────────────────────────────────┘    │
│                           ▼                                     │
│  5. MergeRasterPasses()                                         │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ • 동일 RT 사용 Pass 그룹화                          │    │
│     │ • Begin/EndRenderPass 최소화                        │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Pass 컬링 메커니즘

### 컬링 규칙

```cpp
// 컬링 대상이 되는 경우:
// 1. 출력 리소스가 아무도 사용하지 않음
// 2. 외부로 추출되지 않음
// 3. NeverCull 플래그가 없음

bool ShouldCullPass(FRDGPass* Pass)
{
    // NeverCull 플래그 확인
    if (Pass->Flags & ERDGPassFlags::NeverCull)
        return false;

    // 출력 리소스 사용 여부 확인
    for (auto& Output : Pass->Outputs)
    {
        if (Output->HasConsumers() || Output->bExtracted)
            return false;
    }

    return true;  // 컬링 대상
}
```

```
┌─────────────────────────────────────────────────────────────────┐
│                    컬링 결정 트리                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                    Pass 분석                                    │
│                        │                                        │
│              ┌─────────┴─────────┐                             │
│              ▼                   ▼                             │
│        NeverCull?           출력 사용됨?                        │
│           │                      │                              │
│     ┌─────┴─────┐          ┌─────┴─────┐                       │
│     ▼           ▼          ▼           ▼                       │
│    Yes         No         Yes         No                       │
│     │           │          │           │                        │
│     ▼           │          ▼           │                        │
│  [유지]        │       [유지]         │                        │
│                │                       │                        │
│                └───────────┬───────────┘                       │
│                            ▼                                    │
│                       외부 추출?                                │
│                            │                                    │
│                      ┌─────┴─────┐                             │
│                      ▼           ▼                             │
│                     Yes         No                             │
│                      │           │                              │
│                      ▼           ▼                              │
│                   [유지]      [컬링]                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 배리어 배치 최적화

### 배리어 배치 (FRDGBarrierBatch)

```cpp
class FRDGBarrierBatchBegin
{
    TArray<FRHITransitionInfo> Transitions;
    ERHIPipeline Pipeline;
};

class FRDGBarrierBatchEnd
{
    FRDGBarrierBatchBegin* Begin;
    ERHIPipeline Pipeline;
};
```

### 배리어 병합 전략

```
┌─────────────────────────────────────────────────────────────────┐
│                    배리어 병합 최적화                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  최적화 전:                                                     │
│  ┌──────┐ Barrier ┌──────┐ Barrier ┌──────┐ Barrier ┌──────┐  │
│  │Pass A│────────▶│Pass B│────────▶│Pass C│────────▶│Pass D│  │
│  └──────┘         └──────┘         └──────┘         └──────┘  │
│           Tex1→SRV        Tex2→SRV        Tex3→SRV            │
│                                                                 │
│  최적화 후:                                                     │
│  ┌──────┐                                           ┌──────┐  │
│  │Pass A│  Batched Barrier (Tex1, Tex2, Tex3)      │Pass D│  │
│  └──────┘─────────────────────────────────────────▶└──────┘  │
│                                                                 │
│  • 연속된 배리어를 하나로 병합                                  │
│  • 불필요한 동기화 포인트 제거                                  │
│  • Read-to-Read 전환 생략                                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 비동기 컴퓨트 처리

### Fork-Join 모델

```
┌─────────────────────────────────────────────────────────────────┐
│                    비동기 컴퓨트 Fork-Join                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Graphics Queue          Async Compute Queue                   │
│       │                                                         │
│  ┌────┴────┐                                                   │
│  │ Pass A  │                                                   │
│  │(Graphics)│                                                   │
│  └────┬────┘                                                   │
│       │                                                         │
│       ├─────────── Fork ──────────▶ ┌────────────┐            │
│       │                              │  Pass B    │            │
│       │                              │(AsyncComp) │            │
│       │                              └─────┬──────┘            │
│  ┌────┴────┐                               │                   │
│  │ Pass C  │ ←── Sync Point ────────      │                   │
│  │(Graphics)│                        │     │                   │
│  └────┬────┘                        │     │                   │
│       │                              │     │                   │
│       │◀────────── Join ─────────────┴─────┘                   │
│       │                                                         │
│  ┌────┴────┐                                                   │
│  │ Pass D  │  ← Pass B 결과 사용 가능                          │
│  │(Graphics)│                                                   │
│  └─────────┘                                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 비동기 컴퓨트 의존성 처리

```cpp
// 비동기 컴퓨트 Pass 추가
GraphBuilder.AddPass(
    RDG_EVENT_NAME("AsyncComputePass"),
    Parameters,
    ERDGPassFlags::AsyncCompute,  // 비동기 컴퓨트 플래그
    [](FRHICommandList& RHICmdList)
    {
        // 컴퓨트 셰이더 디스패치
    }
);

// RDG가 자동으로:
// 1. Graphics 큐와의 Fork 포인트 설정
// 2. 필요한 Fence 삽입
// 3. 결과 사용 시 Join 포인트 설정
```

---

## Pass 병합 메커니즘

### 래스터 Pass 병합

동일한 렌더 타겟을 사용하는 연속된 래스터 Pass를 하나의 Render Pass로 병합합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    Pass 병합 예시                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  병합 전:                                                       │
│  ┌────────────────────────────────────────────────────────┐    │
│  │ BeginRenderPass(RT: GBuffer)                            │    │
│  │   DrawBasePass()                                        │    │
│  │ EndRenderPass()                                         │    │
│  │                                                         │    │
│  │ BeginRenderPass(RT: GBuffer)  ← 동일 RT               │    │
│  │   DrawDecals()                                          │    │
│  │ EndRenderPass()                                         │    │
│  │                                                         │    │
│  │ BeginRenderPass(RT: GBuffer)  ← 동일 RT               │    │
│  │   DrawDebugPrimitives()                                 │    │
│  │ EndRenderPass()                                         │    │
│  └────────────────────────────────────────────────────────┘    │
│                                                                 │
│  병합 후:                                                       │
│  ┌────────────────────────────────────────────────────────┐    │
│  │ BeginRenderPass(RT: GBuffer)                            │    │
│  │   DrawBasePass()                                        │    │
│  │   DrawDecals()        ← 병합됨                         │    │
│  │   DrawDebugPrimitives()  ← 병합됨                      │    │
│  │ EndRenderPass()                                         │    │
│  └────────────────────────────────────────────────────────┘    │
│                                                                 │
│  효과:                                                          │
│  • LoadAction/StoreAction 호출 감소                            │
│  • 타일 기반 GPU에서 특히 효과적                               │
│  • 메모리 대역폭 절약                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 실행 단계 상세

### Execute() 함수

```cpp
void FRDGBuilder::Execute()
{
    // 1. 컴파일
    Compile();

    // 2. Pass 순회 실행
    for (FRDGPass* Pass : Passes)
    {
        if (Pass->bCulled)
            continue;

        // Prologue: 배리어, RT 설정
        ExecutePassPrologue(Pass);

        // Body: Lambda 실행
        Pass->Execute(RHICmdList);

        // Epilogue: 정리
        ExecutePassEpilogue(Pass);
    }

    // 3. 정리
    Cleanup();
}
```

### Pass 실행 구조

```
┌─────────────────────────────────────────────────────────────────┐
│                    Pass 실행 구조                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────── Pass N ───────────────┐                      │
│  │                                       │                      │
│  │  Prologue:                           │                      │
│  │  ├── BeginBarrierBatch()             │                      │
│  │  ├── TransitionResources()           │                      │
│  │  ├── EndBarrierBatch()               │                      │
│  │  └── BeginRenderPass() (Raster만)    │                      │
│  │                                       │                      │
│  │  Body:                               │                      │
│  │  └── Lambda(RHICmdList)              │  ← 사용자 코드       │
│  │                                       │                      │
│  │  Epilogue:                           │                      │
│  │  ├── EndRenderPass() (Raster만)      │                      │
│  │  └── ReleaseUnusedResources()        │                      │
│  │                                       │                      │
│  └───────────────────────────────────────┘                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 리소스 생명주기

### 자동 생명주기 관리

```
┌─────────────────────────────────────────────────────────────────┐
│                    리소스 생명주기                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  시간 →   Pass1    Pass2    Pass3    Pass4    Pass5            │
│            │        │        │        │        │               │
│  Tex A:    █████████████████                                   │
│           생성      사용      마지막사용                         │
│                              └─ 풀로 반환                       │
│                                                                 │
│  Tex B:             ███████████████████████                    │
│                    생성      사용      사용     마지막          │
│                                               └─ 풀로 반환     │
│                                                                 │
│  Tex C:                      █████████                         │
│                             생성  마지막                        │
│                                   └─ 풀로 반환                 │
│                                                                 │
│  • 첫 사용 시점에 풀에서 할당                                   │
│  • 마지막 사용 후 즉시 풀로 반환                                │
│  • Tex A가 반환된 메모리를 Tex C가 재사용 가능                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 서브리소스 상태 추적

### 밉맵/배열 슬라이스별 상태

```cpp
// 서브리소스별 다른 상태 가능
struct FRDGTextureSubresourceState
{
    TArray<FRDGSubresourceState> MipStates;     // 밉맵별 상태
    TArray<FRDGSubresourceState> ArrayStates;   // 배열 슬라이스별 상태
};

// 사용 예: 밉맵 0은 SRV, 밉맵 1은 UAV
Pass1: Texture.Mip0 → SRV (읽기)
Pass2: Texture.Mip1 → UAV (쓰기)
// 동시에 다른 밉맵 레벨 접근 가능
```

---

## 다음 단계

[RDG 개발 가이드](04-rdg-development.md)에서 실제 사용법과 코드 예제를 알아봅니다.
