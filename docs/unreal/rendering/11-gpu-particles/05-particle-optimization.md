# 05. 파티클 최적화

Niagara 파티클 시스템의 LOD, 컬링, 성능 최적화 기법을 분석합니다.

---

## 성능 개요

### 파티클 비용 요소

```
┌─────────────────────────────────────────────────────────────────┐
│                    파티클 성능 비용                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 시뮬레이션 비용                                             │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  CPU 시뮬레이션:                                     │    │
│     │  - 파티클 수 × 모듈 복잡도                          │    │
│     │  - 게임 스레드 경합                                  │    │
│     │                                                     │    │
│     │  GPU 시뮬레이션:                                     │    │
│     │  - Compute Shader 비용                              │    │
│     │  - 메모리 대역폭                                    │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  2. 렌더링 비용                                                 │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  - 드로우 콜 (Emitter당)                            │    │
│     │  - 버텍스/픽셀 처리                                 │    │
│     │  - 오버드로 (반투명)                                │    │
│     │  - 정렬 (반투명)                                    │    │
│     │  - 텍스처 샘플링                                    │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  3. 메모리 비용                                                 │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  - 파티클 버퍼 (속성 × 최대 수)                     │    │
│     │  - 텍스처 (스프라이트, 노이즈)                      │    │
│     │  - 메시 (메시 렌더러)                               │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  4. 이벤트/데이터 인터페이스 비용                               │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  - 충돌 쿼리                                        │    │
│     │  - 메시 샘플링                                      │    │
│     │  - 이벤트 전송                                      │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Scalability (확장성)

### Emitter Scalability

```
┌─────────────────────────────────────────────────────────────────┐
│                    Scalability 설정                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Emitter Properties → Scalability:                              │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Spawn Count Scale:                                     │   │
│  │  ├── Low:    0.25  (25% 스폰)                          │   │
│  │  ├── Medium: 0.5   (50% 스폰)                          │   │
│  │  ├── High:   0.75  (75% 스폰)                          │   │
│  │  └── Epic:   1.0   (100% 스폰)                         │   │
│  │                                                         │   │
│  │  Max Particle Count:                                    │   │
│  │  ├── Low:    1000                                      │   │
│  │  ├── Medium: 5000                                      │   │
│  │  ├── High:   20000                                     │   │
│  │  └── Epic:   100000                                    │   │
│  │                                                         │   │
│  │  Cull by Distance:                                      │   │
│  │  ├── Enable per quality level                          │   │
│  │  └── Max Distance: 5000, 10000, 20000, 50000           │   │
│  │                                                         │   │
│  │  Cull by Screen Size:                                   │   │
│  │  └── Min Fraction: 0.01, 0.005, 0.001, 0               │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Engine Scalability Settings에 따라 자동 적용                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 품질 레벨 설정

```cpp
// C++에서 Scalability 설정
void ConfigureScalability(UNiagaraEmitter* Emitter)
{
    FNiagaraEmitterScalabilitySettings& Scalability =
        Emitter->GetScalabilitySettings();

    // 스폰 스케일 (품질별)
    Scalability.SpawnCountScales.SetNum(4);
    Scalability.SpawnCountScales[0] = 0.25f; // Low
    Scalability.SpawnCountScales[1] = 0.5f;  // Medium
    Scalability.SpawnCountScales[2] = 0.75f; // High
    Scalability.SpawnCountScales[3] = 1.0f;  // Epic

    // 거리 컬링
    Scalability.bCullByDistance = true;
    Scalability.MaxDistance.SetNum(4);
    Scalability.MaxDistance[0] = 5000.0f;
    Scalability.MaxDistance[1] = 10000.0f;
    Scalability.MaxDistance[2] = 20000.0f;
    Scalability.MaxDistance[3] = 0.0f; // 무한

    // 화면 크기 컬링
    Scalability.bCullMaxInstanceCount = true;
    Scalability.MaxSystemInstances = 10;
}
```

---

## 거리 기반 LOD

### LOD 시스템

```
┌─────────────────────────────────────────────────────────────────┐
│                    파티클 LOD 시스템                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  거리에 따른 품질 조절:                                         │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                         │   │
│  │  👁 Camera                                              │   │
│  │      │                                                  │   │
│  │      ├──── 0-50m ────┤  Full Quality                   │   │
│  │      │               │  - 모든 파티클                   │   │
│  │      │               │  - 높은 해상도 텍스처            │   │
│  │      │               │  - 모든 모듈 활성                │   │
│  │      │                                                  │   │
│  │      ├──── 50-200m ──┤  Medium Quality                 │   │
│  │      │               │  - 50% 파티클                    │   │
│  │      │               │  - 간소화된 모듈                 │   │
│  │      │                                                  │   │
│  │      ├──── 200-500m ─┤  Low Quality                    │   │
│  │      │               │  - 25% 파티클                    │   │
│  │      │               │  - 기본 모듈만                   │   │
│  │      │                                                  │   │
│  │      └──── 500m+ ────┤  Culled                         │   │
│  │                      │  - 렌더링 안함                   │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 모듈에서 LOD 구현

```hlsl
// 거리 기반 스폰 레이트 조절
// Emitter Update 스크립트에서

// 카메라 거리 계산
float3 EmitterPos = Emitter.LocalSpace ?
    TransformPosition(Emitter.LocalToWorld, float3(0,0,0)) :
    Emitter.Position;

float Distance = length(EmitterPos - Engine.CameraPosition);

// 거리에 따른 스폰 스케일
float SpawnScale = 1.0;
if (Distance > 500.0)
    SpawnScale = 0.0;  // 컬링
else if (Distance > 200.0)
    SpawnScale = 0.25;
else if (Distance > 50.0)
    SpawnScale = 0.5;

// 스폰 레이트 적용
Emitter.SpawnRate = BaseSpawnRate * SpawnScale;
```

---

## 컬링

### 가시성 컬링

```
┌─────────────────────────────────────────────────────────────────┐
│                    컬링 전략                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Frustum Culling (시야 컬링)                                │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  - 카메라 시야 외부 시스템 스킵                     │    │
│     │  - 바운딩 박스 기반                                  │    │
│     │  - 자동 적용                                         │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  2. Distance Culling (거리 컬링)                               │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  - 최대 거리 초과 시 비활성화                       │    │
│     │  - Scalability 설정에서 구성                        │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  3. Screen Size Culling (화면 크기 컬링)                       │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  - 화면에서 너무 작으면 스킵                        │    │
│     │  - 바운드 기반 계산                                  │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  4. Significance Culling (중요도 컬링)                         │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  - 화면 비율, 거리, 우선순위 조합                   │    │
│     │  - Significance Manager 사용                        │    │
│     │  - 동시 활성 시스템 수 제한                         │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  5. Occlusion Culling (오클루전 컬링)                          │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  - 가려진 시스템 스킵                               │    │
│     │  - 하드웨어 오클루전 쿼리                           │    │
│     │  - 비용 있음, 선택적 사용                           │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 바운딩 설정

```cpp
// 바운딩 모드 설정
UPROPERTY()
ENiagaraBoundsMode BoundsMode;

enum class ENiagaraBoundsMode : uint8
{
    // 자동 계산 (느림, 정확)
    Dynamic,

    // 고정 바운드 (빠름, 수동 설정)
    Fixed,

    // 동적 + 고정 확장
    DynamicWithExpansion
};

// 고정 바운드 설정
UPROPERTY()
FBox FixedBounds;  // 수동으로 설정

// 사용 예시
void SetupBounds(UNiagaraSystem* System)
{
    // 고정 바운드 사용 (성능 향상)
    System->bFixedBounds = true;
    System->FixedBounds = FBox(
        FVector(-100, -100, 0),    // Min
        FVector(100, 100, 200)     // Max
    );
}
```

---

## 시뮬레이션 최적화

### CPU 시뮬레이션 최적화

```
┌─────────────────────────────────────────────────────────────────┐
│                    CPU 시뮬레이션 최적화                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 모듈 최소화                                                 │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  - 불필요한 모듈 제거                               │    │
│     │  - 조건부 모듈 사용                                  │    │
│     │  - 유사 기능 병합                                    │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  2. 복잡한 연산 피하기                                         │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  ❌ 삼각함수 (sin, cos, atan)                       │    │
│     │  ❌ 제곱근 (sqrt, length)                           │    │
│     │  ❌ 나눗셈 (대신 곱셈 사용)                         │    │
│     │  ✅ 테이블 룩업                                     │    │
│     │  ✅ 근사 함수                                       │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  3. 업데이트 빈도 조절                                         │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  - Fixed Tick Rate 사용                             │    │
│     │  - 30 FPS 시뮬레이션 (60 FPS 렌더링)                │    │
│     │  - 보간으로 시각적 품질 유지                        │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  4. 비동기 실행                                                 │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  - Async Tick 활성화                                │    │
│     │  - 게임 스레드 부하 분산                            │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### GPU 시뮬레이션 최적화

```
┌─────────────────────────────────────────────────────────────────┐
│                    GPU 시뮬레이션 최적화                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 스레드 그룹 크기                                            │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  - Wave 크기의 배수 (32 또는 64)                    │    │
│     │  - 일반적으로 64 또는 256                           │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  2. 분기 최소화                                                 │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  ❌ if (Particles.Age > Random)                     │    │
│     │     → Divergence 발생                               │    │
│     │                                                     │    │
│     │  ✅ lerp, step, smoothstep으로 대체                 │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  3. 메모리 접근 패턴                                            │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  - 연속 메모리 접근 (SoA)                           │    │
│     │  - Bank Conflict 피하기                             │    │
│     │  - 공유 메모리 활용                                 │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  4. Data Interface 비용                                        │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  - 충돌 쿼리: 비용 높음, 최소화                     │    │
│     │  - 텍스처 샘플: LOD 힌트 사용                       │    │
│     │  - 메시 샘플: 캐싱 활용                             │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 렌더링 최적화

### 오버드로 줄이기

```
┌─────────────────────────────────────────────────────────────────┐
│                    오버드로 최적화                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  문제: 반투명 파티클 중첩                                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │        ┌───┐                                            │   │
│  │      ┌─┼───┼─┐      3개 레이어 = 3× 렌더링              │   │
│  │    ┌─┼─┼───┼─┼─┐                                        │   │
│  │    └─┼─┼───┼─┼─┘                                        │   │
│  │      └─┼───┼─┘                                          │   │
│  │        └───┘                                            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  해결책:                                                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  1. 파티클 수 줄이기 + 크기 키우기                     │   │
│  │     - 적은 수의 큰 파티클                               │   │
│  │                                                         │   │
│  │  2. Cutout Opacity 사용                                │   │
│  │     - 알파 테스트로 early-Z 활용                       │   │
│  │     - 오버드로 대폭 감소                               │   │
│  │                                                         │   │
│  │  3. Additive 블렌드                                    │   │
│  │     - 정렬 불필요                                      │   │
│  │     - 적합한 효과에만                                  │   │
│  │                                                         │   │
│  │  4. 해상도 스케일                                      │   │
│  │     - 파티클을 낮은 해상도로 렌더링                    │   │
│  │     - 업스케일 (약간의 블러)                           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 드로우 콜 최적화

```cpp
// 드로우 콜 줄이기

// 1. Emitter 병합
// - 유사한 효과는 하나의 Emitter로
// - 여러 렌더러 대신 하나의 렌더러

// 2. 머티리얼 공유
// - 동일 머티리얼 사용 시 배칭 가능
// - 파라미터는 Per-Instance Data로

// 3. 메시 아틀라스
// - 여러 메시를 하나로 합치고 인덱스로 선택
// MeshIndex 바인딩 사용

// 4. GPU 파티클 사용
// - CPU 파티클보다 배칭 효율적
```

---

## 프로파일링

### 디버그 도구

```
┌─────────────────────────────────────────────────────────────────┐
│                    Niagara 프로파일링                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  콘솔 명령어:                                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  stat niagara              Niagara 통계                 │   │
│  │  stat niagaraGPU          GPU 시뮬레이션 통계          │   │
│  │  stat particles           파티클 전체 통계             │   │
│  │  stat gpu                  GPU 시간                     │   │
│  │  fx.Niagara.Debug 1       디버그 오버레이              │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Niagara Debugger:                                              │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Window → Developer Tools → Niagara Debugger           │   │
│  │                                                         │   │
│  │  - 활성 시스템 목록                                    │   │
│  │  - 파티클 수                                           │   │
│  │  - 시뮬레이션 시간                                     │   │
│  │  - 렌더 시간                                           │   │
│  │  - 속성 값 실시간 확인                                 │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  GPU Profiler (RenderDoc, PIX):                                │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  - Compute Shader 시간                                 │   │
│  │  - 드로우 콜 분석                                      │   │
│  │  - 오버드로 시각화                                     │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 최적화 체크리스트

```
┌─────────────────────────────────────────────────────────────────┐
│                    최적화 체크리스트                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  시뮬레이션:                                                    │
│  □ 적절한 Sim Target 선택 (CPU/GPU)                           │
│  □ 파티클 수 제한 (MaxParticleCount)                          │
│  □ 불필요한 모듈 제거                                          │
│  □ 복잡한 수학 연산 최소화                                     │
│  □ Fixed Tick Rate 고려                                        │
│                                                                 │
│  렌더링:                                                        │
│  □ 오버드로 최소화 (Cutout, Additive)                         │
│  □ 적절한 정렬 모드 선택                                       │
│  □ 텍스처 해상도 최적화                                        │
│  □ LOD 구현                                                    │
│                                                                 │
│  메모리:                                                        │
│  □ 텍스처 압축 사용                                            │
│  □ 파티클 버퍼 크기 적정화                                     │
│  □ 풀링 활성화                                                 │
│                                                                 │
│  컬링:                                                          │
│  □ 거리 컬링 설정                                              │
│  □ 화면 크기 컬링 설정                                         │
│  □ 고정 바운드 사용 (가능하면)                                 │
│  □ Significance 설정                                           │
│                                                                 │
│  Scalability:                                                   │
│  □ 품질 레벨별 설정                                            │
│  □ 스폰 스케일 조절                                            │
│  □ 거리별 LOD                                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 요약

파티클 최적화 핵심:

1. **Scalability** - 품질 레벨별 스폰 스케일, 파티클 수 제한
2. **LOD** - 거리 기반 품질 조절, 원거리 컬링
3. **컬링** - Frustum, Distance, Screen Size, Significance
4. **시뮬레이션** - CPU/GPU 선택, 모듈 최소화, 분기 피하기
5. **렌더링** - 오버드로 감소, 드로우 콜 최적화

프로파일링 기반으로 병목을 찾아 최적화하세요.

---

## 참고 자료

- [Niagara Performance](https://docs.unrealengine.com/5.0/en-US/niagara-performance-optimization/)
- [원문 시리즈 (중국어)](https://www.cnblogs.com/timlly/p/13512787.html)
