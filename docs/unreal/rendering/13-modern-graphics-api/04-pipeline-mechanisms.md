# Pipeline 메커니즘

PSO, 동기화, 메모리 관리 메커니즘을 설명합니다.

---

## Pipeline State Object (PSO)

### 개념

PSO는 렌더링에 필요한 모든 상태를 하나의 불변 객체로 통합합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    PSO 구성 요소                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Graphics PSO:                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Shader Stages                                          │   │
│  │  ├── Vertex Shader                                      │   │
│  │  ├── Hull Shader (선택)                                 │   │
│  │  ├── Domain Shader (선택)                               │   │
│  │  ├── Geometry Shader (선택)                             │   │
│  │  └── Pixel Shader                                       │   │
│  │                                                         │   │
│  │  Fixed Function States                                  │   │
│  │  ├── Input Layout (정점 포맷)                           │   │
│  │  ├── Rasterizer State (컬링, 와이어프레임 등)           │   │
│  │  ├── Depth Stencil State                                │   │
│  │  ├── Blend State                                        │   │
│  │  ├── Render Target Formats                              │   │
│  │  └── MSAA Settings                                      │   │
│  │                                                         │   │
│  │  Root Signature / Pipeline Layout                       │   │
│  │  └── 리소스 바인딩 레이아웃 정의                        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Compute PSO:                                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  ├── Compute Shader                                     │   │
│  │  └── Root Signature / Pipeline Layout                   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### PSO 장점

```
┌─────────────────────────────────────────────────────────────────┐
│                    PSO 장점                                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  레거시 API 방식:                                               │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  SetVertexShader(vs);                                   │   │
│  │  SetPixelShader(ps);      각 호출마다                   │   │
│  │  SetBlendState(blend);    드라이버가 상태 검증         │   │
│  │  SetDepthState(depth);    → 오버헤드!                  │   │
│  │  Draw();                                                │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  PSO 방식:                                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  // 초기화 시 한 번 생성 (수백 ms 소요 가능)           │   │
│  │  PSO = CreatePSO(vs, ps, blend, depth, ...);            │   │
│  │                                                         │   │
│  │  // 렌더링 시 빠르게 교체                              │   │
│  │  SetPSO(pso);  // 단일 호출, 검증 없음                 │   │
│  │  Draw();                                                │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  결과:                                                          │
│  • 런타임 셰이더 컴파일 제거                                   │
│  • Draw Call당 CPU 오버헤드 대폭 감소                          │
│  • 예측 가능한 성능                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### PSO 생성 전략

```cpp
// PSO 생성 (별도 스레드에서)
void CreatePSOAsync()
{
    // 시간이 오래 걸릴 수 있음 (수백 ms)
    std::async(std::launch::async, [&]() {
        D3D12_GRAPHICS_PIPELINE_STATE_DESC desc = {};
        desc.pRootSignature = rootSignature;
        desc.VS = { vsBlob->GetBufferPointer(), vsBlob->GetBufferSize() };
        desc.PS = { psBlob->GetBufferPointer(), psBlob->GetBufferSize() };
        desc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
        desc.BlendState = CD3DX12_BLEND_DESC(D3D12_DEFAULT);
        desc.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
        // ...

        device->CreateGraphicsPipelineState(&desc, IID_PPV_ARGS(&pso));
    });
}
```

---

## 동기화 메커니즘

### 세 가지 동기화 타입

```
┌─────────────────────────────────────────────────────────────────┐
│                    동기화 메커니즘                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Barrier (배리어)                                            │
│     용도: GPU 내부 명령 간 동기화                              │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  Draw(toTexture) → Barrier → Sample(texture)       │    │
│     │                      ↑                              │    │
│     │              상태 전환 + 캐시 플러시                │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  2. Fence (펜스)                                                │
│     용도: CPU-GPU 동기화                                       │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  CPU                  GPU                           │    │
│     │   │                    │                            │    │
│     │   │ Submit(cmdBuffer) │                            │    │
│     │   │───────────────────▶│ Execute                   │    │
│     │   │                    │   ...                      │    │
│     │   │                    │ Signal(fence)              │    │
│     │   │ Wait(fence)       │                            │    │
│     │   │◀───────────────────│                            │    │
│     │   │                    │                            │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  3. Semaphore (세마포어)                                        │
│     용도: Queue 간 동기화                                      │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  Graphics Queue         Compute Queue               │    │
│     │       │                      │                      │    │
│     │       │ Signal(sem)          │                      │    │
│     │       │─────────────────────▶│ Wait(sem)            │    │
│     │       │                      │ Compute...           │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Barrier 사용 가이드

```
┌─────────────────────────────────────────────────────────────────┐
│                    Barrier 최적화                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  규칙: "배리어 수는 쓰기 표면 수의 약 2배 정도"                 │
│                                                                 │
│  배리어가 필요한 경우:                                          │
│  • RenderTarget → ShaderResource                               │
│  • UAV 쓰기 → 읽기                                             │
│  • 포맷/레이아웃 변경                                          │
│                                                                 │
│  배리어가 불필요한 경우:                                        │
│  • 읽기 → 읽기 (같은 상태)                                     │
│  • 동일한 파이프라인 내 연속 사용                              │
│                                                                 │
│  배리어 배칭:                                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  // 나쁜 예: 개별 배리어                                │   │
│  │  Barrier(texA);                                         │   │
│  │  Barrier(texB);                                         │   │
│  │  Barrier(texC);                                         │   │
│  │                                                         │   │
│  │  // 좋은 예: 배치 배리어                                │   │
│  │  Barrier({texA, texB, texC});                           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  주의: "배리어 누락은 타이밍 이슈와 데이터 손상을 유발"         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 메모리 관리

### 메모리 할당 방식

```
┌─────────────────────────────────────────────────────────────────┐
│                    메모리 할당 방식                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Committed Resource (전용 할당)                              │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  • 리소스당 개별 메모리 할당                        │    │
│     │  • 용도: RTV, DSV, UAV 등 중요 리소스              │    │
│     │  • 단점: 메모리 단편화 가능                        │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  2. Placed Resource (배치 할당)                                 │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  Heap ┌────────────────────────────────────┐        │    │
│     │       │ Res A │ Res B │ Res C │ ...        │        │    │
│     │       └────────────────────────────────────┘        │    │
│     │  • 미리 할당된 Heap에 리소스 배치                   │    │
│     │  • 용도: 유사한 수명의 리소스 그룹화               │    │
│     │  • 장점: 메모리 효율성                              │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
│  3. Reserved/Tiled Resource (예약 할당)                         │
│     ┌─────────────────────────────────────────────────────┐    │
│     │  • 가상 주소만 예약, 물리 메모리는 필요 시 매핑    │    │
│     │  • 용도: Virtual Texture, 스트리밍                 │    │
│     │  • 장점: 유연한 메모리 관리                        │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Heap 타입

```
┌─────────────────────────────────────────────────────────────────┐
│                    Heap 타입                                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Default Heap (GPU 전용):                                       │
│  ├── GPU에서만 접근 가능                                       │
│  ├── 최고 성능                                                 │
│  └── 용도: 렌더 타겟, 텍스처, 정적 버퍼                        │
│                                                                 │
│  Upload Heap (CPU → GPU):                                       │
│  ├── CPU에서 쓰기 가능                                         │
│  ├── GPU에서 읽기 가능                                         │
│  └── 용도: 상수 버퍼, 동적 버퍼, 스테이징                      │
│                                                                 │
│  Readback Heap (GPU → CPU):                                     │
│  ├── GPU에서 쓰기 가능                                         │
│  ├── CPU에서 읽기 가능                                         │
│  └── 용도: 스크린샷, GPU 쿼리 결과                             │
│                                                                 │
│  리소스 전송 패턴:                                              │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  CPU → Upload Heap → Copy → Default Heap → GPU 사용    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 메모리 관리 전략

```
┌─────────────────────────────────────────────────────────────────┐
│                    메모리 관리 권장사항                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  "애플리케이션 개발자가 드라이버보다                           │
│   리소스의 중요도를 더 잘 알고 있다"                           │
│                                                                 │
│  전략:                                                          │
│  1. 중요 리소스는 VRAM에 유지                                  │
│     • 자주 사용되는 텍스처                                     │
│     • 렌더 타겟                                                │
│                                                                 │
│  2. 비중요 리소스는 시스템 메모리로 이동 가능                  │
│     • 스트리밍 텍스처의 낮은 밉맵                              │
│     • 비활성 레벨 데이터                                       │
│                                                                 │
│  3. 리소스 앨리어싱 활용                                       │
│     • 동시에 사용되지 않는 리소스는 메모리 공유               │
│     • RDG가 자동으로 관리                                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 다음 단계

[통합 응용](05-integrated-apps.md)에서 RHI와 GPU-Driven 렌더링을 알아봅니다.
