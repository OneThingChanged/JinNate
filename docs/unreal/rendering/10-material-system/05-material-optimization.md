# 05. 머티리얼 최적화

머티리얼 복잡도 관리, LOD 시스템, 성능 최적화 기법을 분석합니다.

---

## 성능 개요

### 머티리얼 비용 요소

```
┌─────────────────────────────────────────────────────────────────┐
│                    머티리얼 성능 비용                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  명령어 수 (Instruction Count):                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  - 수학 연산, 함수 호출                                  │   │
│  │  - 복잡한 노드 그래프 = 많은 명령어                      │   │
│  │  - ALU 병목 유발 가능                                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  텍스처 샘플링:                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  - 각 텍스처 샘플 = 메모리 대역폭 사용                   │   │
│  │  - 종속적 읽기 (UV 계산 후 샘플) = 레이턴시              │   │
│  │  - 높은 해상도/밉맵 = 캐시 압박                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  셰이더 순열:                                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  - 많은 정적 스위치 = 순열 폭발                         │   │
│  │  - 컴파일 시간 증가                                     │   │
│  │  - 셰이더 캐시 크기 증가                                │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  오버드로:                                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  - 반투명: 뒤에서 앞으로 여러 번 그리기                 │   │
│  │  - 복잡한 머티리얼 × 오버드로 = 성능 저하              │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 복잡도 분석

### Shader Complexity 뷰

```
┌─────────────────────────────────────────────────────────────────┐
│                    셰이더 복잡도 시각화                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  뷰포트 → Lit → Shader Complexity                              │
│                                                                 │
│  색상 의미:                                                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  녹색      낮은 복잡도 (< 50 instructions)              │   │
│  │  노란색    중간 복잡도 (50-100 instructions)            │   │
│  │  빨간색    높은 복잡도 (100-200 instructions)           │   │
│  │  분홍/흰색 매우 높음 (200+ instructions)                │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  추가 뷰:                                                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Shader Complexity with Quad Overdraw                   │   │
│  │  - 쿼드 오버드로까지 포함한 실제 비용                   │   │
│  │                                                         │   │
│  │  Shader Complexity (with PS Only)                       │   │
│  │  - 픽셀 셰이더만의 복잡도                               │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  머티리얼 통계 (Stats 노드):                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Base pass shader: 125 instructions                     │   │
│  │  Texture samplers: 5                                    │   │
│  │  Texture lookups: 6                                     │   │
│  │  Virtual texture lookups: 0                             │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 명령어 카운트 확인

```cpp
// 머티리얼 통계 가져오기
void LogMaterialStats(UMaterial* Material)
{
    FMaterialResource* Resource = Material->GetMaterialResource(GMaxRHIFeatureLevel);
    if (Resource)
    {
        // 셰이더 맵에서 통계 추출
        FMaterialShaderMap* ShaderMap = Resource->GetGameThreadShaderMap();

        for (const auto& Pair : ShaderMap->GetShaders())
        {
            FShader* Shader = Pair.Value;

            UE_LOG(LogMaterial, Log, TEXT("Shader: %s"),
                *Shader->GetType()->GetName());
            UE_LOG(LogMaterial, Log, TEXT("  Instructions: %d"),
                Shader->GetNumInstructions());
            UE_LOG(LogMaterial, Log, TEXT("  Texture Samplers: %d"),
                Shader->GetNumTextureSamplers());
        }
    }
}
```

---

## 텍스처 최적화

### 텍스처 샘플 줄이기

```
┌─────────────────────────────────────────────────────────────────┐
│                    텍스처 최적화 기법                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 채널 패킹:                                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  개별 텍스처:                                           │   │
│  │  - Roughness.png (1 sample)                             │   │
│  │  - Metallic.png (1 sample)                              │   │
│  │  - AO.png (1 sample)                                    │   │
│  │  = 3 samples                                            │   │
│  │                                                         │   │
│  │  패킹 후:                                               │   │
│  │  - ORM.png (R=AO, G=Roughness, B=Metallic)             │   │
│  │  = 1 sample                                             │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  2. 텍스처 아틀라스:                                            │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  여러 작은 텍스처를 하나로 합침                         │   │
│  │  UV 좌표로 영역 선택                                    │   │
│  │  상태 변경 감소                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  3. 공유 샘플러:                                                │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Shared: Wrap/Clamp 샘플러 재사용                       │   │
│  │  D3D12: 16개 샘플러 제한                                │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  4. 적절한 해상도:                                              │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  모든 텍스처가 4K일 필요 없음                           │   │
│  │  디테일 텍스처: 1K-2K                                   │   │
│  │  마스크/노이즈: 256-512                                 │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 종속적 텍스처 읽기 피하기

```hlsl
// ❌ 종속적 읽기 (Dependent Texture Read)
// UV가 다른 텍스처 결과에 의존
float2 OffsetUV = DistortionTexture.Sample(UV).rg;  // 첫 번째 샘플
float4 Color = ColorTexture.Sample(UV + OffsetUV);  // 두 번째 - 대기 필요!

// ✅ 독립적 읽기 (가능한 경우)
// 미리 계산된 UV 사용
float4 Color = ColorTexture.Sample(PrecomputedUV);

// ✅ 또는 수학적 UV 변형
float2 WaveUV = UV + sin(Time + UV.x * 10) * 0.01;  // 수식 기반
float4 Color = ColorTexture.Sample(WaveUV);
```

---

## 노드 최적화

### 비용 높은 노드

```
┌─────────────────────────────────────────────────────────────────┐
│                    노드별 비용                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  저비용:                                                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Constant, Parameter                     (~0 inst)      │   │
│  │  Add, Subtract, Multiply, Divide         (~1 inst)      │   │
│  │  Lerp                                    (~2 inst)      │   │
│  │  ComponentMask, Append                   (~1 inst)      │   │
│  │  Saturate, Clamp                         (~1 inst)      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  중간 비용:                                                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  TextureSample                           (~4-8 inst)    │   │
│  │  Dot Product                             (~3 inst)      │   │
│  │  Normalize                               (~3 inst)      │   │
│  │  Power                                   (~3-5 inst)    │   │
│  │  Sin, Cos                                (~4 inst)      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  고비용:                                                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Fresnel                                 (~8-15 inst)   │   │
│  │  Noise                                   (~20-50 inst)  │   │
│  │  Ray Marching loops                      (~100+ inst)   │   │
│  │  Distance Field 연산                     (~10-30 inst)  │   │
│  │  Screen Position → UV 변환               (~5-10 inst)   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  피해야 할 패턴:                                                │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  - 과도한 Noise 레이어                                  │   │
│  │  - 불필요한 Normalize                                   │   │
│  │  - 반복되는 동일 계산                                   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 최적화 팁

```hlsl
// ❌ 비효율적
float3 N1 = normalize(Normal1);
float3 N2 = normalize(Normal2);
float3 Result = normalize(N1 + N2);  // 3번 normalize

// ✅ 최적화
float3 Result = normalize(Normal1 + Normal2);  // 1번만

// ❌ 중복 계산
float A = sin(Time * 2.0) * 0.5 + 0.5;
float B = sin(Time * 2.0) * 0.3 + 0.7;

// ✅ 재사용
float SinVal = sin(Time * 2.0);
float A = SinVal * 0.5 + 0.5;
float B = SinVal * 0.3 + 0.7;

// ❌ 비싼 Power
float Falloff = pow(1 - NdotV, 5);

// ✅ Schlick 근사
float x = 1 - NdotV;
float x2 = x * x;
float Falloff = x2 * x2 * x;  // x^5
```

---

## 머티리얼 LOD

### Quality Switch

```
┌─────────────────────────────────────────────────────────────────┐
│                    Quality Switch 노드                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  [Quality Switch]                                               │
│      ├── High   ──→ [복잡한 노드 체인]                          │
│      ├── Medium ──→ [중간 복잡도]                               │
│      ├── Low    ──→ [단순화된 버전]                             │
│      └── Default ──→ [폴백]                                     │
│                                                                 │
│  설정: Engine Scalability Settings → Material Quality          │
│                                                                 │
│  예시:                                                          │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  High:                                                  │   │
│  │  - 디테일 노멀맵 2장 블렌딩                             │   │
│  │  - 복잡한 Fresnel 효과                                  │   │
│  │  - 고해상도 텍스처                                      │   │
│  │                                                         │   │
│  │  Low:                                                   │   │
│  │  - 단일 노멀맵                                          │   │
│  │  - 단순 Fresnel                                         │   │
│  │  - 저해상도 텍스처                                      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Material LOD

```cpp
// 머티리얼 품질 스케일러빌리티
// Project Settings → Engine → Rendering → Material Quality Level

// 런타임 품질 변경
void SetMaterialQuality(int32 QualityLevel)
{
    // 0 = Low, 1 = Medium, 2 = High, 3 = Epic
    static IConsoleVariable* CVar = IConsoleManager::Get().FindConsoleVariable(
        TEXT("r.MaterialQualityLevel"));

    if (CVar)
    {
        CVar->Set(QualityLevel);
    }
}

// 머티리얼에서 품질 확인
// Material Editor → Quality Switch 노드 사용
```

---

## 반투명 최적화

### 반투명 성능 영향

```
┌─────────────────────────────────────────────────────────────────┐
│                    반투명 렌더링 비용                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  문제점:                                                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  1. 포워드 렌더링 (디퍼드 라이팅 불가)                  │   │
│  │  2. 뒤에서 앞으로 정렬 (CPU 오버헤드)                   │   │
│  │  3. 오버드로 (겹치는 영역 여러 번 렌더링)              │   │
│  │  4. 배칭 어려움                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  최적화 전략:                                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  1. 반투명 최소화                                       │   │
│  │     - Masked로 대체 가능하면 사용                       │   │
│  │     - Dithered Opacity로 반투명 효과 모방               │   │
│  │                                                         │   │
│  │  2. 간단한 셰이더                                       │   │
│  │     - Unlit 사용 (라이팅 비용 제거)                     │   │
│  │     - 텍스처 최소화                                     │   │
│  │                                                         │   │
│  │  3. 화면 비율 제한                                      │   │
│  │     - 작은 오브젝트에만 사용                            │   │
│  │     - 풀스크린 반투명 피하기                            │   │
│  │                                                         │   │
│  │  4. 정렬 모드                                           │   │
│  │     - Sort Priority 설정                                │   │
│  │     - Disable Depth Test 주의                           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Dithered Opacity

```
┌─────────────────────────────────────────────────────────────────┐
│                    디더드 불투명도                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  원리:                                                          │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  - Masked 블렌드 모드 사용                              │   │
│  │  - 디더 패턴으로 픽셀을 부분적으로 버림                 │   │
│  │  - TAA로 부드럽게 블렌딩                                │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  노드 구성:                                                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  [Opacity] ──→ [DitherTemporalAA] ──→ [OpacityMask]    │   │
│  │                                                         │   │
│  │  또는:                                                  │   │
│  │  [Opacity] ──→ [DitheringMaterial] ──→ [OpacityMask]   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  장점:                                                          │
│  - 디퍼드 라이팅 사용 가능                                     │
│  - 정렬 불필요                                                 │
│  - 성능 향상                                                   │
│                                                                 │
│  단점:                                                          │
│  - TAA 없으면 노이즈 보임                                      │
│  - 완벽한 반투명은 아님                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 모바일 최적화

### 모바일 특화 설정

```
┌─────────────────────────────────────────────────────────────────┐
│                    모바일 머티리얼 최적화                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  권장 사항:                                                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  1. 명령어 수: < 100 (이상적으로 < 50)                  │   │
│  │  2. 텍스처 샘플: < 5                                    │   │
│  │  3. Feature Level ES3.1 타겟                            │   │
│  │  4. Fully Rough 사용 고려                               │   │
│  │  5. High Quality Reflections 비활성화                   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  모바일 전용 설정:                                              │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Material → Mobile                                      │   │
│  │  ├── Use Full Precision: 꺼두기 (half 사용)             │   │
│  │  ├── Forward Shading: 가능하면 사용                     │   │
│  │  └── Use Lightmap Directionality: 필요시만              │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  텍스처:                                                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  - ASTC 압축 사용 (iOS/Android)                         │   │
│  │  - 해상도 낮추기 (512-1024 권장)                        │   │
│  │  - 밉맵 생성                                            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 프로파일링

### 머티리얼 성능 측정

```cpp
// GPU 프로파일링 마커
SCOPED_DRAW_EVENT(RHICmdList, MaterialName);

// 콘솔 명령어
// stat gpu                   GPU 시간
// profilegpu                 상세 GPU 프로파일
// stat scenerendering        씬 렌더링 통계
// r.ShaderComplexityColors   복잡도 색상 확인

// 머티리얼 통계 콘솔
// stat material              머티리얼 통계
// r.Material.AllowTextureErrors  텍스처 오류 확인
```

### 성능 체크리스트

```
┌─────────────────────────────────────────────────────────────────┐
│                    머티리얼 최적화 체크리스트                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  □ 텍스처 채널 패킹 (ORM 등)                                   │
│  □ 불필요한 텍스처 샘플 제거                                    │
│  □ 적절한 텍스처 해상도 선택                                    │
│  □ 반복되는 계산 제거                                          │
│  □ Quality Switch로 LOD 구현                                   │
│  □ 반투명 대신 Masked/Dithered 고려                            │
│  □ Shader Complexity 뷰로 확인                                 │
│  □ 정적 스위치 최소화                                          │
│  □ 머티리얼 인스턴스 활용                                       │
│  □ MPC로 전역 파라미터 관리                                    │
│  □ 모바일 타겟 시 별도 최적화                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 요약

머티리얼 최적화 핵심:

1. **복잡도 분석** - Shader Complexity 뷰, 명령어 수 확인
2. **텍스처 최적화** - 채널 패킹, 해상도 조절, 샘플 수 감소
3. **노드 최적화** - 비용 높은 노드 피하기, 중복 계산 제거
4. **LOD** - Quality Switch로 품질별 분기
5. **반투명** - 최소화, Dithered Opacity 활용

프로파일링 기반으로 병목을 찾아 최적화하는 것이 중요합니다.

---

## 참고 자료

- [UE Material Optimization](https://docs.unrealengine.com/5.0/en-US/material-optimization-guide/)
- [원문 시리즈 (중국어)](https://www.cnblogs.com/timlly/p/13512787.html)
